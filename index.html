<!DOCTYPE html>
<html>
  <head>
    <title>The did:cel Method v0.3</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
    <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove'></script>
    <script src="https://cdn.jsdelivr.net/gh/digitalbazaar/respec-vc@3.4.2/dist/main.js" class="remove"></script>
    <script type="text/javascript" class="remove">
      var respecConfig = {
        // specification status (e.g., WD, LCWD, NOTE, etc.). If in doubt use ED.
        specStatus: "CG-DRAFT",

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName: "did-cel",

        // subtitle for the spec
        subtitle: "A DID Method based on witnessed cryptographic event logs",

        // if you wish the publication date to be other than today, set this
        //publishDate: "",
        //crEnd: "",
        //prEnd: "",
        //implementationReportURI: "",

        // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
        // and its maturity status
        // previousPublishDate:  "1977-03-15",
        // previousMaturity:  "WD",

        // extend the bibliography entries
        localBiblio: {
          'THORMARKER': {
            title: 'On using the same key pair for Ed25519 and an X25519 based KEM',
            href: 'https://eprint.iacr.org/2021/509.pdf',
            authors: ['Erik Thormarker'],
            status: 'Internet-Draft',
            publisher: 'Cryptology ePrint Archive'
          }
        },
        doJsonLd: true,

        github: "https://github.com/w3c-ccg/did-cel-spec",
        includePermalinks: false,

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: "https://w3c-ccg.github.io/did-cel-spec/",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // editors, add as many as you like
        // only "name" is required
        editors: [
          { name: "Manu Sporny", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/" }
        ],
        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.
        authors:
        [
          { name: "Dave Longley", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/"},
          { name: "Manu Sporny", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/" }
        ],
        group: 'credentials',

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI from a random
        // document unless you know what you're doing. If in doubt ask your friendly neighborhood
        // Team Contact.
        wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/98922/status",
        maxTocLevel: 2,
        inlineCSS: true,
        postProcess: [],
        xref: [
          "infra", "web-platform", "did", "vc-data-model",
          "vc-data-integrity"
        ],
        lint: {
          "informative-dfn": false
        },
        otherLinks: [{
          key: "Related Documents",
          data: [{
            value: "Controlled Identifiers v1.0",
            href: "https://www.w3.org/TR/cid/"
          }, {
            value: "Decentralized Identifiers v1.0",
            href: "https://www.w3.org/TR/did/"
          }, {
            value: "DID Use Cases and Requirements",
            href: "https://www.w3.org/TR/did-use-cases/"
          }, {
            value: "DID Core Implementation Report",
            href: "https://w3c.github.io/did-test-suite/"
          }]
        }]
      };
    </script>
    <style>
code {
  color: rgb(199, 73, 0);
  font-weight: bold;
}
pre {
  overflow-x: auto;
  white-space: pre-wrap;
}
pre .highlight {
  font-weight: bold;
  color: Green;
}
pre .subject {
  font-weight: bold;
  color: RoyalBlue;
}
pre .property {
  font-weight: bold;
  color: DarkGoldenrod;
}
pre .comment {
  font-weight: bold;
  color: SteelBlue;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
ol.algorithm { counter-reset:numsection; list-style-type: none; }
ol.algorithm li { margin: 0.5em 0; }
ol.algorithm li:before { font-weight: bold; counter-increment: numsection; content: counters(numsection, ".") ") "; }

table.simple {
    border-collapse: collapse;
    margin: 25px 0;
    min-width: 400px;
    border: 1px solid #dddddd;
}
table.simple thead tr {
    background-color: #005a9c;
    color: #ffffff;
    text-align: left;
}
table.simple th,
table.simple td {
    padding: 12px 15px;
    vertical-align: top;
    text-align: left;
}
table.simple tbody tr {
    border-bottom: 1px solid #dddddd;
}
table.simple tbody tr:nth-of-type(even) {
    background-color: #00000008;
}
table.simple tbody tr:last-of-type {
    border-bottom: 2px solid #005a9c;
}
    </style>
  </head>
  <body>
    <section id='abstract'>
      <p>
[=Decentralized Identifiers=] (DIDs) are a type of identifier for verifiable,
decentralized digital identity. These identifiers are designed to enable the
controller of a DID to prove control over the identifier in a way that is
independent of any centralized registry, identity provider, or certificate authority.
These sorts of identifiers often utilize a heavy-weight registry, such as ones
utilizing Decentralized Ledger Technologies (DLT), to create, read, update,
and deactivate [=DIDs=]. This specification describes a [=witness=]-based [=DID
Method=] where each DID Document's history is contained in a [=cryptographic
event log=] where each event is [=witnessed=] by one or more trusted entities. The
approach avoids the need for complex decentralized consensus algorithms as well
as expensive proof-of-work or proof-of-stake systems.
      </p>
    </section>

    <section id='sotd'>

      <p>
      </p>

    </section>

    <section class="informative">
      <h2>Introduction</h2>

      <p>
In today's digital world, your online identity is controlled by companies and
organizations that maintain databases of usernames, passwords, and personal
information. When you create an account with a service, that service owns your
identity—they can lock you out, change the rules, or even shut down entirely,
taking your identity and connections with it. The `did:cel` method offers a
fundamentally different approach: it enables you to create and control your
own digital identifier without relying on any single company, organization, or
centralized database. Your [=DID=] belongs to you alone, stored and managed
using cryptographic techniques that prove ownership without needing anyone's
permission or approval.
      </p>

      <p>
What makes `did:cel` truly decentralized is its [=witness=]-based architecture,
which eliminates any single point of control or failure. Unlike traditional
systems where a company's servers must be online for you to prove who you are,
or blockchain-based systems where you depend on a specific network to function,
`did:cel` distributes trust across multiple independent [=witnesses=] that attest
to changes in your identity information. These [=witnesses=] don't control your
identity—they simply provide timestamped confirmations that certain changes
occurred. You choose which [=witnesses=] to use, and because no single [=witness=] has
special authority, no one entity can block your access, censor your identity,
or force unwanted changes. This architectural choice means your identity
remains under your control even if individual [=witnesses=] become unavailable or
act maliciously.
      </p>

      <p>
This decentralization directly empowers individuals to own their identity and
data online in meaningful ways. With `did:cel`, you can prove who you are and
what credentials or permissions you hold without asking permission from
gatekeepers. You can take your identity with you across different services and
platforms, establishing trust relationships on your own terms. If a service you
use shuts down or changes its policies in ways you disagree with, your
underlying identity remains intact and under your control—you simply use it
with a different service. This represents a fundamental shift from identity as
something granted by institutions to identity as an inherent digital right that
you exercise through cryptographic proofs. When you control your identifier,
you control your digital presence, your relationships, and your data.
      </p>

      <p>
This specification describes the complete technical framework for the `did:cel`
method. The <a href="#did-cel-identifier-syntax">Identifier Syntax</a> section
explains how [=DIDs=] are constructed using cryptographic hashes. The
<a href="#operations">Operations</a> section details how to create, update,
read, [=witness=], and deactivate [=DID documents=], including the [=cryptographic
event log=] that maintains the complete history of changes. The
<a href="#privacy-considerations">Privacy Considerations</a> section examines
privacy implications of maintaining public event logs and offers mitigation
strategies. Finally, the <a href="#security-considerations">Security
Considerations</a> section addresses potential security risks and provides
guidance for secure implementation and deployment of the `did:cel` method.
      </p>

      <section>
        <h3>Terminology</h3>

        <p>
Some terminology used throughout this document is defined in the
<a data-cite="CID#terminology">Terminology</a> section of the [[[CID]]]
specification, the
<a data-cite="DID#terminology">Terminology</a> section of the [[[DID]]]
specification, and the
<a data-cite="VC-DATA-INTEGRITY#terminology">Terminology</a> section of the
[[[VC-DATA-INTEGRITY]]] specification. This section defines additional terms
used throughout this specification.
        </p>

        <dl class="termlist definitions" data-sort="ascending">

          <dt><dfn class="export" data-lt="CEL">cryptographic event log</dfn></dt>
          <dd>
A [=hashlinked=] chain of events that records the complete history of operations
performed on a document with each event cryptographically tied to the
preceding event.
          </dd>

          <dt><dfn class="export" data-lt="hashlinked|hashlinking">hashlink</dfn></dt>
          <dd>
A mechanism of connecting data through cryptographic hashes such that an
observer can cryptographically verify that the contents of the data that is
pointed to has not been modified since the link was created.
          </dd>

          <dt><dfn class="export">self-certifying identifier</dfn></dt>
          <dd>
A type of identifier derived directly from the cryptographic hash of data. The
approach creates an intrinsic binding between the identifier and its content
without requiring external registration or validation.
          </dd>

          <dt><dfn class="export" data-lt="witnesses|witnessed|witnessing">witness</dfn></dt>
          <dd>
An independent entity that provides cryptographic attestation to data in a
[=cryptographic event log=] by creating [=data integrity proofs=], enabling
distributed validation without needing to store or control the data being
attested to. Multiple <strong>witnesses</strong> can attest to the same data,
and the process of creating such attestations is called
<strong>witnessing</strong>.
          </dd>

        </dl>
      </section>

      <section id="conformance"></section>

    </section>

    <section class="normative">
      <h2>did:cel Identifier Syntax</h2>

      <p>
The format for the `did:cel` method conforms to the [[[DID]]] specification and
is simple. It consists of the `did:cel` prefix, followed by a <a
data-cite="CID#Multibase">Multibase</a> base58-btc encoded value
that is a concatenation of the <a data-cite="CID#Multihash">Multihash</a>
identifier and the corresponding cryptographic digest for the initial
[=cryptographic event log=] entry.
      </p>

      <p>
The ABNF for the key format is described below:
      </p>

      <pre>
did-cel-format := did:cel:&lt;mb-value>
mb-value       := z[a-km-zA-HJ-NP-Z1-9]+
      </pre>

      <p>
Alternatively, the encoding rules can also be thought of as the application
of a series of transformation functions on the raw public key bytes:
      </p>

      <tt>
did-cel-identifier := did:cel:MULTIBASE(base58-btc, MULTICODEC(sha3-256, JCS(initial-event-log-entry)))
      </tt>

      <p>
A simple example of a valid `did:cel` DID is:
      </p>

      <pre class="example nohighlight" title="A valid did:cel identifier">
did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE
      </pre>

    </section>

    <section class="normative">
      <h2>Operations</h2>

      <p>
The following section outlines the DID operations for the `did:cel` method.
      </p>

      <section class="normative">
        <h3>Create</h3>

        <p>
The create operation establishes a new `did:cel` [=DID document=] with a
[=self-certifying identifier=] derived from the document's cryptographic hash. This
operation generates an initial cryptographic key pair, constructs a [=DID document=] containing
the public key as an assertion method, and adds a [=data integrity proof=] to
the document. This approach ensures that the [=DID=] is intrinsically
bound to the document's initial state, providing strong integrity guarantees
without requiring external registration.
        </p>

        <p>
Once the [=DID document=] is created and signed, a [=cryptographic event log=] (CEL) is
initialized to track the complete history of operations on this DID. The log's
first entry is a `create` event that contains the signed [=DID document=] as its
data payload. This event serves as the cryptographic foundation for all
subsequent updates, enabling verifiable audit trails and [=witness=] attestation.
The combination of the [=self-certifying identifier=], cryptographic proof, and
event log creates a decentralized identifier implementation that requires no
centralized authority for creation, validation, or resolution.
        </p>

        <p>
An example of a [=cryptographic event log=] containing the creation event for a
`did:cel` [=DID=] is shown below.
        </p>

        <pre class="example nohighlight" title="Cryptographic event log after did:cel creation">
{
  "log": [
    {
      "event": {
        "operation": {
          "type": "create",
          "data": {
            "@context": [
              "https://www.w3.org/ns/did/v1.1",
              "https://w3id.org/didcel/v1"
            ],
            "id": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB",
            "assertionMethod": [
              {
                "id": "#zDnaezPhQRKeXLBs2jjHc8e6gZdhRxvm9fzmrvPf3rqZRDnig",
                "type": "Multikey",
                "controller": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB",
                "publicKeyMultibase": "zDnaezPhQRKeXLBs2jjHc8e6gZdhRxvm9fzmrvPf3rqZRDnig"
              }
            ],
            "service": {
              "type": "CelStorageService",
              "serviceEndpoint": [
                "https://storage.gamma.example/v1",
                "https://2001:db8:85a3::8a2e:370:7334/v1",
                "https://celstorageiu7vnjjbwkhpilnemxj7ase3mhbshg7kx5tfydaniltxjqhy.onion/"
              ]
            }
          }
        },
        "proof": {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:26:17Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z5rEayhU67tsThi4ncBWX8okqzmDsBkfVA6dE39QGR9vJwTHz5Qa8vvZRQYvE8imUPwiseFCF2s6bNMpz5MJ5m2Yw",
          "verificationMethod": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB#zDnaezPhQRKeXLBs2jjHc8e6gZdhRxvm9fzmrvPf3rqZRDnig"
        }
      }
    }
  ]
}
        </pre>

        <section class="normative">
          <h4>Document Creation Algorithm</h4>

          <p>
The following algorithm specifies how to create a new `did:cel` DID
document with an initial verification method and establish a cryptographic event
log. The algorithm takes an optional [=map=] |options| as input. The |options|
map MAY contain a |keyType| property specifying an cryptographic key type to use
(defaults to `P-256`). Output is a [=map=] containing the generated
|didDocument|, the associated |keyPair|, and the initial
|cryptographicEventLog|, or an error. Whenever this algorithm encodes strings,
it MUST use UTF-8 encoding.
          </p>

          <ol class="algorithm">
            <li>
Let |keyType| be set to |options|.|keyType| if present, otherwise set to
`P-256`. The |keyType| value MUST be a valid keyType identifier
supported by the <a data-cite="CID#Multikey">Multikey</a> specification.
            </li>
            <li>
Generate a new key pair based on |keyType|. Let |keyPair| be the result. If key
generation fails, an error MUST be raised and SHOULD convey an error type of
`KEY_GENERATION_ERROR`.
            </li>
            <li>
Export the public key from |keyPair| as a <a
data-cite="CID#Multikey">Multikey</a> value. Let |publicKey| be the result.
            </li>
            <li>
Create an initial [=DID document=] structure ([=map=] |didDocument|) with the
following properties:
              <ol class="algorithm">
                <li>
Set |didDocument|.`@context` to an array containing the following
two strings: `https://www.w3.org/ns/did/v1.1` and `https://w3id.org/didcel/v1`.
                </li>
                <li>
Set |didDocument|.`assertionMethod` to an array containing a single
verification method object with the following properties:
                  <ol class="algorithm">
                    <li>
Set the verification method's `id` value to the concatenation of the
`#` character and the `publicKeyMultibase` value of the |publicKey|.
                    </li>
                    <li>
Set the verification method's `type` to `Multikey`.
                    </li>
                    <li>
Set the verification method's `publicKeyMultibase` to
|publicKey|.`publicKeyMultibase`.
                    </li>
                    <li>
Add a <a data-cite="CID#services">service entry</a> where the `type` is
`CelStorageService` and the `serviceEndpoint` is a list of URLs that the
controller will use to store the canonical version of the
[=cryptographic event log=].
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>
Generate the [=DID=] by hashing the canonicalized [=DID document=]:
              <ol class="algorithm">
                <li>
Canonicalize |didDocument| using JSON Canonicalization Scheme (JCS) as specified
in [[RFC8785]]. Let |canonicalizedDidDocument| be the result.
                </li>
                <li>
Compute the SHA3-256 <a data-cite="CID#Multihash">Multihash</a> of the
UTF-8 encoded canonicalized document. Let |hash| be the result.
                </li>
                <li>
Encode |hash| using base58-btc encoding, prepending the
<a data-cite="CID#Multibase">Multibase</a> (`z`) character to the encoding. Let
|encodedHash| be the result.
                </li>
                <li>
Set |didDocument|.`id` to the concatenated value of `did:cel:` and
the |encodedHash|.
                </li>
                <li>
Set the `controller` property of the verification method in
|didDocument|.`assertionMethod` to |didDocument|.`id`.
                </li>
              </ol>
            </li>
            <li>
Generate the |event| object by performing the following steps:
              <ol class="algorithm">
                <li>
The event object MUST contain a [=map=] with an `operation` property.
                </li>
                <li>
The `operation` [=map=] MUST contain:
                  <ol class="algorithm">
                    <li>
A `type` property with the value `create`.
                    </li>
                    <li>
A `data` property containing the |didDocument|.
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>
Generate a cryptographic proof for |event| using a cryptosuite
that is compatible with the generated |keyPair|, such as
<a data-cite="VC-DI-ECDSA#ecdsa-jcs-2019">ecdsa-jcs-2019</a>. Set the
`proofPurpose` to `assertionMethod`. Add the `proof` to the |event|.
            </li>
            <li>
Create the initial [=cryptographic event log=]:
              <ol class="algorithm">
                <li>
Create a new [=map=] |cryptographicEventLog| with a `log` property
set to an array containing the |event| object.
                </li>
              </ol>
            </li>
            <li>
Return a [=map=] containing:
              <ol class="algorithm">
                <li>
|didDocument|: the completed [=DID document=] with the computed identifier
                </li>
                <li>
|keyPair|: the generated key pair (including secret key material)
                </li>
                <li>
|cryptographicEventLog|: the initial event log with the create event
                </li>
              </ol>
            </li>
          </ol>

        </section>

      </section>

      <section class="normative">
        <h3>Witness</h3>

        <p>
The [=witness=] operation provides independent cryptographic attestation for events
in a [=cryptographic event log=], establishing temporal evidence and distributed
validation of [=DID=] operations. After a [=DID document=] is modified, [=witness=]
services—independent entities operating under their own authority—generate
[=data integrity proofs=] over events in the log. Each [=witness=] returns a
cryptographic proof that attests the event existed and was [=witnessed=] at a
specific point in time.
        </p>

        <p>
The [=witnessing=] process does not modify the event itself; rather, it produces a
collection of cryptographic proofs that are attached to the event structure for
subsequent verification. These [=witness=] attestations serve multiple purposes:
they provide temporal anchoring by demonstrating when an event was [=witnessed=],
enable auditability through independent third-party validation, and increase
resistance to tampering by distributing trust across multiple independent
[=witnesses=]. Unlike centralized timestamp authorities, the [=witness=] architecture
allows [=DID controllers=] to select [=witness=] services, preventing single points of
failure while maintaining cryptographic verifiability of the entire event
history.
        </p>

        <pre class="example nohighlight" title="Cryptographic event log after witnessing">
{
  "log": [
    {
      "event": {
        "operation": {
          "type": "create",
          "data": {
            "@context": [
              "https://www.w3.org/ns/did/v1.1",
              "https://w3id.org/didcel/v1"
            ],
            "id": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB",
            "assertionMethod": [
              {
                "id": "#zDnaezPhQRKeXLBs2jjHc8e6gZdhRxvm9fzmrvPf3rqZRDnig",
                "type": "Multikey",
                "controller": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB",
                "publicKeyMultibase": "zDnaezPhQRKeXLBs2jjHc8e6gZdhRxvm9fzmrvPf3rqZRDnig"
              }
            ],
            "service": {
              "type": "CelStorageService",
              "serviceEndpoint": [
                "https://storage.gamma.example/v1",
                "https://2001:db8:85a3::8a2e:370:7334/v1",
                "https://celstorageiu7vnjjbwkhpilnemxj7ase3mhbshg7kx5tfydaniltxjqhy.onion/"
              ]
            }
          }
        },
        "proof": {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:26:17Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z5rEayhU67tsThi4ncBWX8okqzmDsBkfVA6dE39QGR9vJwTHz5Qa8vvZRQYvE8imUPwiseFCF2s6bNMpz5MJ5m2Yw",
          "verificationMethod": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB#zDnaezPhQRKeXLBs2jjHc8e6gZdhRxvm9fzmrvPf3rqZRDnig"
        }
      },
      "proof": [
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:37:52Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "zSX9hg5VPkxBTHRiZmYpC8Ytx5Bk5n9dpVrnZZ14bXiUoMoqe592zF2ekhD9x9LBgRS2febTu3Eedp87FVheZLxi",
          "verificationMethod": "did:web:red-witness.example#vm-red-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:37:52Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "zsQFw4FDBvnvQMPRGf2y5D1EiuPxnomTE416QtrpfJEXpKaRB7S2pZTY3tTQ9cQcLrBW6zrreGVgR3ULtouvbsC7",
          "verificationMethod": "did:web:green-witness.example#vm-green-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:37:52Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "zBzKKLtmUea4hWPs5F63w29bXvUCPxyN4GzmXWUMNwxWD5otDRnKh2w7Z7e5vVRwhL8RicACbb3yxVmti8ZLqxj9",
          "verificationMethod": "did:web:blue-witness.example#vm-blue-1"
        }
      ]
    }
  ]
}
        </pre>

        <section class="normative">
          <h4>Document Witnessing Algorithm</h4>

          <p>
The following algorithm specifies how to generate [=witness=] attestations for the
most recent event in a [=cryptographic event log=]. [=Witnesses=] are independent
entities that cryptographically sign events to provide decentralized validation
and auditability. The algorithm takes a [=map=] |cel| as input, which is the
[=cryptographic event log=] containing one or more events. Output is an array of
proof objects, one from each configured [=witness=], or an error. Whenever this
algorithm encodes strings, it MUST use UTF-8 encoding.
          </p>

          <ol class="algorithm">
            <li>
Initialize an empty array |proofs| to collect [=witness=] attestations.
            </li>
            <li>
Let |event| be the most recent event in |cel|.|log|. This is obtained by
accessing the last event in the array.
            </li>
            <li>
Let |witnesses| be an array of [=witness=] endpoint URLs that are trusted by the
controller of the [=DID=].
            </li>
            <li>
For each |witness| endpoint in |witnesses|, perform the following steps:
              <ol class="algorithm">
                <li>
Canonicalize |event| using the JSON Canonicalization Scheme (JCS) as specified
in [[RFC8785]]. Let |canonicalizedEvent| be the result.
                </li>
                <li>
Compute the SHA3-256 <a data-cite="CID#Multihash">Multihash</a> of the
UTF-8 encoded |canonicalizedEvent|. Let |hash| be the result.
                </li>
                <li>
Encode |hash| using base58-btc encoding, prepending the
<a data-cite="CID#Multibase">Multibase</a> (`z`) character to the encoding. Let
|encodedHash| be the result.
                </li>
                <li>
Send a [=witnessing=] request to the |witness| by performing an HTTP POST on the
[=witness=] endpoint. The body of the POST is a JSON object containing a
`digestMultibase` property with |encodedHash| as the associated value. Let
|proof| be the result. If [=witnessing=] fails, an error MUST be raised and SHOULD
convey an error type of `WITNESSING_ERROR`.
                </li>
                <li>
Append |proof| to the |proofs| array.
                </li>
              </ol>
            </li>
            <li>
Set |event|.`proof` to the |proofs| array containing attestations from all
[=witnesses=]. Each proof in the array represents an independent cryptographic
commitment by a [=witness=] that the event is valid and has been [=witnessed=] at a
specific point in time.
            </li>
          </ol>

          <p class="note">
The [=witness=] operation does not modify the [=cryptographic event log=] itself. The
returned proofs are attached to the event in the log structure. [=Witnesses=]
provide independent validation and temporal attestation, enabling auditability
and resistance to single points of failure in the DID method infrastructure.
          </p>

        </section>

      </section>

      <section class="normative">
        <h3>Read</h3>

        <p>
        </p>

        <pre class="example nohighlight" title="Cryptographic event log where a read is performed">
{
  "log": [
    {
      "event": {
        "operation": {
          "type": "create",
          "data": {
            "@context": [
              "https://www.w3.org/ns/did/v1.1",
              "https://w3id.org/didcel/v1"
            ],
            "id": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB",
            "assertionMethod": [
              {
                "id": "#zDnaezPhQRKeXLBs2jjHc8e6gZdhRxvm9fzmrvPf3rqZRDnig",
                "type": "Multikey",
                "controller": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB",
                "publicKeyMultibase": "zDnaezPhQRKeXLBs2jjHc8e6gZdhRxvm9fzmrvPf3rqZRDnig"
              }
            ],
            "service": {
              "type": "CelStorageService",
              "serviceEndpoint": [
                "https://storage.gamma.example/v1",
                "https://2001:db8:85a3::8a2e:370:7334/v1",
                "https://celstorageiu7vnjjbwkhpilnemxj7ase3mhbshg7kx5tfydaniltxjqhy.onion/"
              ]
            }
          }
        },
        "proof": {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:26:17Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z5rEayhU67tsThi4ncBWX8okqzmDsBkfVA6dE39QGR9vJwTHz5Qa8vvZRQYvE8imUPwiseFCF2s6bNMpz5MJ5m2Yw",
          "verificationMethod": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB#zDnaezPhQRKeXLBs2jjHc8e6gZdhRxvm9fzmrvPf3rqZRDnig"
        }
      },
      "proof": [
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:37:52Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "zSX9hg5VPkxBTHRiZmYpC8Ytx5Bk5n9dpVrnZZ14bXiUoMoqe592zF2ekhD9x9LBgRS2febTu3Eedp87FVheZLxi",
          "verificationMethod": "did:web:red-witness.example#vm-red-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:37:52Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "zsQFw4FDBvnvQMPRGf2y5D1EiuPxnomTE416QtrpfJEXpKaRB7S2pZTY3tTQ9cQcLrBW6zrreGVgR3ULtouvbsC7",
          "verificationMethod": "did:web:green-witness.example#vm-green-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:37:52Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "zBzKKLtmUea4hWPs5F63w29bXvUCPxyN4GzmXWUMNwxWD5otDRnKh2w7Z7e5vVRwhL8RicACbb3yxVmti8ZLqxj9",
          "verificationMethod": "did:web:blue-witness.example#vm-blue-1"
        }
      ]
    }
  ]
}
        </pre>

        <section class="normative">
          <h4>Document Read Algorithm</h4>

          <p>
          </p>

          <ol class="algorithm">
            <li>
            </li>
          </ol>

        </section>

      </section>

      <section class="normative">
        <h3>Update</h3>

        <p>
The update operation enables modifications to an existing `did:cel` [=DID
document=] while maintaining a verifiable audit trail through the [=cryptographic
event log=]. When changes are made to a [=DID document=]—such as adding or removing
verification methods, updating service endpoints, or setting expiration
dates—the update operation ensures these modifications are cryptographically
signed and recorded in the event log. The operation proceeds in two phases:
first, the modified [=DID document=] receives a fresh [=data integrity proof=]
signed by an authorized assertion method key; second, a new update event is
appended to the [=cryptographic event log=] with a hash link to the previous event,
creating an immutable chain of document history.
        </p>

        <p>
The [=hashlinking=] mechanism is central to the update operation's security
properties. Each update event includes a `previousEvent` property containing the
SHA3-256 hash of the prior event. This cryptographic chain ensures that any
tampering with historical events would be immediately detectable, as it would
break the hash links throughout the chain. The combination of cryptographic
proofs on the [=DID document=] and [=hashlinked=] events in the log provides both
authenticity guarantees (the document was signed by an authorized key) and
integrity guarantees (the complete history of changes is verifiable and
tamper-evident). After performing an update, implementations typically invoke
the [=witness=] operation to obtain independent temporal attestations of the
modification.
        </p>

        <p>
An example of an update operation serialized to a [=cryptographic event log=]
is shown below:
        </p>

        <pre class="example nohighlight" title="Cryptographic event log after did:cel update">
{
  "log": [
    {
      "event": {
        "operation": {
          "type": "create",
          "data": {
            "@context": [
              "https://www.w3.org/ns/did/v1.1",
              "https://w3id.org/didcel/v1"
            ],
            "id": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB",
            "assertionMethod": [
              {
                "id": "#zDnaezPhQRKeXLBs2jjHc8e6gZdhRxvm9fzmrvPf3rqZRDnig",
                "type": "Multikey",
                "controller": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB",
                "publicKeyMultibase": "zDnaezPhQRKeXLBs2jjHc8e6gZdhRxvm9fzmrvPf3rqZRDnig"
              }
            ],
            "service": {
              "type": "CelStorageService",
              "serviceEndpoint": [
                "https://storage.gamma.example/v1",
                "https://2001:db8:85a3::8a2e:370:7334/v1",
                "https://celstorageiu7vnjjbwkhpilnemxj7ase3mhbshg7kx5tfydaniltxjqhy.onion/"
              ]
            }
          }
        },
        "proof": {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:26:17Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z5rEayhU67tsThi4ncBWX8okqzmDsBkfVA6dE39QGR9vJwTHz5Qa8vvZRQYvE8imUPwiseFCF2s6bNMpz5MJ5m2Yw",
          "verificationMethod": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB#zDnaezPhQRKeXLBs2jjHc8e6gZdhRxvm9fzmrvPf3rqZRDnig"
        }
      },
      "proof": [
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:37:52Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "zSX9hg5VPkxBTHRiZmYpC8Ytx5Bk5n9dpVrnZZ14bXiUoMoqe592zF2ekhD9x9LBgRS2febTu3Eedp87FVheZLxi",
          "verificationMethod": "did:web:red-witness.example#vm-red-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:37:52Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "zsQFw4FDBvnvQMPRGf2y5D1EiuPxnomTE416QtrpfJEXpKaRB7S2pZTY3tTQ9cQcLrBW6zrreGVgR3ULtouvbsC7",
          "verificationMethod": "did:web:green-witness.example#vm-green-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:37:52Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "zBzKKLtmUea4hWPs5F63w29bXvUCPxyN4GzmXWUMNwxWD5otDRnKh2w7Z7e5vVRwhL8RicACbb3yxVmti8ZLqxj9",
          "verificationMethod": "did:web:blue-witness.example#vm-blue-1"
        }
      ]
    },
    {
      "event": {
        "previousEvent": "zW1cK1miKeVLGgGRoAgVRKTJ1Bxvb1ygGULyxrnPPxFC7NJ",
        "operation": {
          "type": "update",
          "data": {
            "@context": [
              "https://www.w3.org/ns/did/v1.1",
              "https://w3id.org/didcel/v1"
            ],
            "id": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB",
            "assertionMethod": [
              {
                "id": "#zDnaezPhQRKeXLBs2jjHc8e6gZdhRxvm9fzmrvPf3rqZRDnig",
                "type": "Multikey",
                "controller": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB",
                "publicKeyMultibase": "zDnaezPhQRKeXLBs2jjHc8e6gZdhRxvm9fzmrvPf3rqZRDnig"
              }
            ],
            "authentication": [
              {
                "id": "#zDnaeinPfANwFVj52nkxPBJ3d6S621NDMJGPFfAZ9WCZZqYf7",
                "type": "Multikey",
                "controller": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB",
                "publicKeyMultibase": "zDnaeinPfANwFVj52nkxPBJ3d6S621NDMJGPFfAZ9WCZZqYf7"
              }
            ],
            "service": {
              "type": "CelStorageService",
              "serviceEndpoint": [
                "https://storage.gamma.example/v1",
                "https://2001:db8:85a3::8a2e:370:7334/v1",
                "https://celstorageiu7vnjjbwkhpilnemxj7ase3mhbshg7kx5tfydaniltxjqhy.onion/"
              ]
            }
          }
        },
        "proof": {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:43:45Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z4ncRzZdBTYc7FbX5ib9LMV18RvgTwGRhgaGoPHdFaXh7iBGCs5DiK1Q2BgBmeWUTswewK8bxFeqmgrjJ8DMkQ93a",
          "verificationMethod": "did:cel:zW1mVBvptfdLyssm7WtqPvCet4zA9PKqzc1hsiHmNN8T1KB#zDnaezPhQRKeXLBs2jjHc8e6gZdhRxvm9fzmrvPf3rqZRDnig"
        }
      },
      "proof": [
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:44:11Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z42oANGtrYgnxuHEHKW8unxPpWeYq1U7TkkFwx6J5CGdqjCEB4bvNiDJ639wFdiyMCGKRbzjWtJHC6JhfyUirG6Rf",
          "verificationMethod": "did:web:red-witness.example#vm-red-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:44:11Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z3MeMFXXVkxVRMnyGH8LGgyTYAEH4Bs6ESGCktPk6hRto5dRqFqfNuFtEJQUNBRNZeBsVqHqLZFqM4VNLP4RLNF9W",
          "verificationMethod": "did:web:green-witness.example#vm-green-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-04T20:44:11Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z3pVRdWRRiFwYorthyGJPcALgCKasrgMwTtfcYNnb1L9esf4ERPteUszD5oRH3qJUuqq1C1Z1odsRZEobGoNY2X45",
          "verificationMethod": "did:web:blue-witness.example#vm-blue-1"
        }
      ]
    }
  ]
}
        </pre>

        <section class="normative">
          <h4>Document Update Algorithm</h4>

          <p>
The following algorithm specifies how to update an existing `did:cel`
[=DID document=] and record the change in the [=cryptographic event log=]. The update
operation consists of two phases: regenerating the cryptographic proof on the
modified [=DID document=], and appending a [=hashlinked=] update event to the log. The
algorithm takes a [=map=] |didDocument| (the modified [=DID document=]), a [=map=]
|assertionMethod| (the key pair to use for signing), and a [=map=] |cel| (the
existing [=cryptographic event log=]) as input. Output is the updated |didDocument|
with a new proof and the updated |cel| with the new event appended, or an error.
Whenever this algorithm encodes strings, it MUST use UTF-8 encoding.
          </p>

          <ol class="algorithm">
            <li>
Update the proof on the [=DID Document=] by performing the following steps:
              <ol class="algorithm">
                <li>
Let |newDidDocument| be a copy of |didDocument|.
                </li>
                <li>
If |newDidDocument| contains a `proof` property, remove it. Any
existing proof will be replaced with a new proof reflecting the current state
of the document.
                </li>
                <li>
Create a [=data integrity proof=] with the cryptosuite and a signer derived from
|assertionMethod|. Let |proof| be the result of this step.
                </li>
                <li>
Set |newDidDocument|.`proof` to |proof|.
                </li>
                <li>
Set |didDocument| to |newDidDocument|.
                </li>
              </ol>
            </li>
            <li>
Append the update event to the [=cryptographic event log=] by performing the
following steps:
              <ol class="algorithm">
                <li>
If |cel|.`log` does not contain any events, an error MUST be raised and
SHOULD convey an error type of `MALFORMED_CEL_ERROR`.
                </li>
                <li>
Perform the following steps to create a hash link to the previous event:
                  <ol class="algorithm">
                    <li>
Let |lastEvent| be the most recent event in |cel|.`log`, which will be the
last entry in the array.
                    </li>
                    <li>
Canonicalize |lastEvent| using JSON Canonicalization Scheme (JCS) as specified
in [[RFC8785]]. Let |canonicalizedEvent| be the result.
                    </li>
                    <li>
Compute the SHA3-256 <a data-cite="CID#Multihash">Multihash</a> of the
UTF-8 encoded |canonicalizedEvent|. Let |hash| be the result.
                    </li>
                    <li>
Encode |hash| using base58-btc encoding, prepending the
<a data-cite="CID#Multibase">Multibase</a> (`z`) character to the encoding. Let
|encodedHash| be the result.
                    </li>
                  </ol>
                </li>
                <li>
Create a new event object ([=map=] |updateEvent|) with the following structure:
                  <ol class="algorithm">
                    <li>
Set |updateEvent|.`event` to a new [=map=].
                    </li>
                    <li>
Set |updateEvent|.`event`.`previousEvent` to |encodedHash|.
This creates the [=hashlinked=] chain connecting this event to the previous event.
                    </li>
                    <li>
Set |updateEvent|.`event`.`operation` to a new [=map=].
                    </li>
                    <li>
Set |updateEvent|.`event`.`operation`.`type` to the string `update`.
                    </li>
                    <li>
Set |updateEvent|.`event`.`operation`.`data`
to the updated |didDocument| (which now includes the new proof).
                    </li>
                  </ol>
                </li>
                <li>
Append |updateEvent| to |cel|.`log`.
                </li>
              </ol>
            </li>
            <li>
Return the updated |didDocument| and updated |cel|. The |didDocument| now has
a fresh cryptographic proof, and the |cel| contains a new [=hashlinked=] event
recording the update operation.
            </li>
          </ol>

          <p class="note">
The update operation maintains the integrity of the [=cryptographic event log=]
through [=hashlinking=]. Each update event includes a `previousEvent` property
containing the hash of the prior event, creating a verifiable chain that
prevents tampering and enables auditing of the [=DID document=]'s complete history.
After updating, implementations invoke the [=witness=] operation to obtain
independent attestations of the update event.
          </p>

        </section>

      </section>

      <section class="normative">
        <h3>Deactivate</h3>

        <p>
        </p>

        <pre class="example nohighlight" title="Cryptographic event log after did:cel deactivation">
{
  "log": [
    {
      "@context": [
        "https://w3id.org/security/data-integrity/v2"
      ],
      "event": {
        "operation": {
          "type": "create",
          "data": {
            "@context": "https://www.w3.org/ns/did/v1.1",
            "id": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
            "assertionMethod": [
              {
                "id": "#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
              }
            ],
            "proof": {
              "type": "DataIntegrityProof",
              "cryptosuite": "ecdsa-jcs-2019",
              "created": "2025-12-03T12:41:21Z",
              "proofPurpose": "assertionMethod",
              "proofValue": "z3Z2BFFtVSZPjFGipCazyD8CLp8U5ovw4Mvvk4SkvNL3dgXrAH3PMeTDvxJzS9wd9dUrxLCAr3c53t2CmnNbcgscd",
              "verificationMethod": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
            }
          }
        }
      },
      "proof": [
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-03T12:44:32Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z5zybUDUyKkxgmHNYN8a3N4A33rKVv5pmnXHmHvbkXnkXrvfVFTSYNZxUr6C4QqEUoVdHJbtHykzVKr8rDLcE1zU9",
          "verificationMethod": "did:web:red-witness.example#vm-red-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-03T12:44:32Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z2c9Y4nBvGpQfyTzDcgmEjnVxaMTJNdPxfEmA8i4JwfVTe9jwRFQvSRSodEMqiVGwADMzW7dmqrAjecfm67nda7bW",
          "verificationMethod": "did:web:green-witness.example#vm-green-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-03T12:44:32Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z9QXFEcjThByMsLj5XbEmRwpzKh2318QvAhrM9V4Ddxni2mSgV1TW2e9J2Eqg4pQr9eWq3eBEa5gdGVon7Ba8d25",
          "verificationMethod": "did:web:blue-witness.example#vm-blue-1"
        }
      ]
    },
    {
      "@context": [
        "https://w3id.org/security/data-integrity/v2"
      ],
      "event": {
        "previousEvent": "zW1h4Eejr9bT2uZUWVvStrA61QBUUVLgjW8zC63QUvGMbc7",
        "operation": {
          "type": "update",
          "data": {
            "@context": "https://www.w3.org/ns/did/v1.1",
            "id": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
            "assertionMethod": [
              {
                "id": "#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
              }
            ],
            "authentication": [
              {
                "id": "#zDnaevoeYvJDAdbTPzuiBkDyk83VL1cWK68aUGUopvLBuUVMj",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaevoeYvJDAdbTPzuiBkDyk83VL1cWK68aUGUopvLBuUVMj"
              }
            ],
            "proof": {
              "type": "DataIntegrityProof",
              "cryptosuite": "ecdsa-jcs-2019",
              "created": "2025-12-03T12:56:25Z",
              "proofPurpose": "assertionMethod",
              "proofValue": "z4AAsnpBKdMd5fws1Gjy2gQeyuTBXGM9fXrg3kS53nsF4f2hDGRmLUhWcgnMTuaC3FCAsVNRCbUah4X6Efm5kmA2T",
              "verificationMethod": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
            }
          }
        }
      },
      "proof": [
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-14T15:43:08Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z2XXjpGHZMK2c5X2aeqS7AQ1uZDwQpvoNyCPqp4DrTUowqvAKq9NwSRFsBYKg58Hj1DmtRkku4ELPS3UbJQGQYDnk",
          "verificationMethod": "did:web:red-witness.example#vm-red-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-14T15:43:08Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z4tDHCFcWcpMDenJWSVDEBg2eEDEZq46PL1cG4XKc157QwWfWBPTDwXdzFi6xQoRRhTdRYCvw3oHAxG1oaQ35JzKc",
          "verificationMethod": "did:web:green-witness.example#vm-green-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-14T15:43:08Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "zPdSjfJ5egfLjRU2Cppt1avQ726acTKgtPJnvJURarMcvEkRJXCDeRKh4bWGreyHKgfvNZxFVe97g4MmsWL7bdKG",
          "verificationMethod": "did:web:blue-witness.example#vm-blue-1"
        }
      ]
    },
    {
      "event": {
        "previousEvent": "zW1gXfEvNdtiphfwXSJYT3aYEkGrVtm3HNiknPEq8mS6vDK",
        "operation": {
          "type": "deactivate",
          "data": {
            "@context": "https://www.w3.org/ns/did/v1.1",
            "id": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
            "assertionMethod": [
              {
                "id": "#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
              }
            ],
            "authentication": [
              {
                "id": "#zDnaevoeYvJDAdbTPzuiBkDyk83VL1cWK68aUGUopvLBuUVMj",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaevoeYvJDAdbTPzuiBkDyk83VL1cWK68aUGUopvLBuUVMj"
              }
            ],
            "proof": {
              "type": "DataIntegrityProof",
              "cryptosuite": "ecdsa-jcs-2019",
              "created": "2025-12-03T13:01:13Z",
              "proofPurpose": "assertionMethod",
              "proofValue": "z4H2BvSz53LPmoQphooggR3STDvftuTji7QTTyegGfKxNBfuvTjpNJBBMhkt7VPz2RX2U9i6jtKBXuHXfgjwu3ABB",
              "verificationMethod": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
            }
          }
        }
      },
      "proof": [
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-14T15:43:08Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z2XXjpGHZMK2c5X2aeqS7AQ1uZDwQpvoNyCPqp4DrTUowqvAKq9NwSRFsBYKg58Hj1DmtRkku4ELPS3UbJQGQYDnk",
          "verificationMethod": "did:web:red-witness.example#vm-red-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-14T15:43:08Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z4tDHCFcWcpMDenJWSVDEBg2eEDEZq46PL1cG4XKc157QwWfWBPTDwXdzFi6xQoRRhTdRYCvw3oHAxG1oaQ35JzKc",
          "verificationMethod": "did:web:green-witness.example#vm-green-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-14T15:43:08Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "zPdSjfJ5egfLjRU2Cppt1avQ726acTKgtPJnvJURarMcvEkRJXCDeRKh4bWGreyHKgfvNZxFVe97g4MmsWL7bdKG",
          "verificationMethod": "did:web:blue-witness.example#vm-blue-1"
        }
      ]
    }
  ]
}
        </pre>

        <section class="normative">
          <h4>Document Deactivation Algorithm</h4>

          <p>
          </p>

          <ol class="algorithm">
            <li>
            </li>
          </ol>

        </section>

      </section>

    </section>

    <section class="informative">
      <h2>Privacy Considerations</h2>

      <p>
This section contains a variety of privacy considerations that people using
the `did:cel` Method are advised to consider before deploying this
technology in a production setting. Readers are urged to read the
<a data-cite="?CID#privacy-considerations">Privacy Considerations</a> section
of the [[[CID]]] specification, as well as the
<a data-cite="?DID#privacy-considerations">Privacy Considerations</a> section
of the [[[DID]]] specification, before reading this section.
      </p>

      <section>
        <h3>Public Event Log Visibility</h3>

        <p>
The [=cryptographic event log=] ([=CEL=]) for a DID is designed to be publicly
verifiable, which means that the complete history of [=DID document=] operations,
including creation, updates, additions, and removals of verification methods
and services, is permanently recorded and accessible. This transparency
enables auditability and trust but comes at the cost of revealing temporal
patterns and the evolution of a DID's capabilities over time. Observers can
analyze the log to determine when verification methods were added or expired,
when services were introduced or removed, and how frequently the [=DID document=]
has been modified.
        </p>

        <p>
To mitigate this privacy concern, implementers might carefully consider what
information is included in [=DID documents=] and when updates are performed.
Batch multiple related changes into a single update operation when possible
to reduce the granularity of information exposed through temporal analysis.
For use cases requiring higher privacy, consider using ephemeral [=DIDs=] that
are rotated regularly, or employing [=DIDs=] with shorter active periods for
their event logs. Organizations might also document their [=DID Document=]
update policies to help users understand the privacy implications of using
their [=DID=]-related services.
        </p>
      </section>

      <section>
        <h3>Correlation via Witness Selection</h3>

        <p>
The [=CEL=] architecture relies on [=witness=] services to provide attestations for
DID operations. The specific set of [=witnesses=] chosen to attest to an event
can serve as a correlatable fingerprint, especially if the [=witness=]
configuration is unique or rarely used. If a DID consistently uses the same
set of [=witnesses=] across multiple operations, or if the [=witness=] selection
pattern is distinctive, observers might be able to correlate different [=DIDs=]
or activities as belonging to the same entity or organization. This
correlation risk increases when custom [=witness=] services are deployed or when
non-standard [=witness=] configurations are used.
        </p>

        <p>
To reduce correlation risk, implementers might use commonly deployed and
widely adopted [=witness=] services when privacy is a concern. Using the same
[=witness=] configuration as other entities in the ecosystem provides herd
privacy by making it difficult to distinguish one [=DID controller=] from
another based solely on [=witness=] selection. For higher privacy requirements,
consider implementing [=witness=] rotation strategies where different [=witness=]
sets are used for different operations, though this might be balanced against
the operational complexity and verification requirements. Standardizing
[=witness=] selection policies across an ecosystem can also help establish common
configurations that enhance privacy through ubiquity.
        </p>
      </section>

      <section>
        <h3>Temporal Metadata Leakage</h3>

        <p>
Each event in the [=CEL=] includes temporal information, either explicitly
through timestamps in [=witness=] proofs or implicitly through the sequence and
timing of operations. This temporal metadata can reveal patterns about the
DID controller's activities, operational hours, time zones, or response times
to security incidents. For example, if verification methods are consistently
updated during specific hours, this might reveal information about the
organization's business hours or geographic location. Rapid succession of
updates might indicate automated processes or security incidents, while long
periods of inactivity followed by bursts of activity can reveal operational
patterns.
        </p>

        <p>
Implementers can mitigate temporal metadata leakage by implementing delays or
jitter in update operations to obscure the precise timing of changes.
Automated systems might avoid predictable update schedules and instead use
randomized timing within acceptable windows. For sensitive operations,
consider batching updates and releasing them at randomized intervals to
prevent timing correlation. Organizations might also be aware that even
without explicit timestamps, the sequence of events and [=witness=] attestation
timing can leak temporal information, so careful consideration of when to
perform DID operations is important for privacy-sensitive use cases.
        </p>
      </section>

      <section>
        <h3>Hash-Linked History Immutability</h3>

        <p>
The [=hashlinking=] mechanism that chains events together in the [=CEL=] provides
strong integrity guarantees but also creates an immutable, permanent record
of all DID operations. Once an event is added to the log and [=witnessed=], it
cannot be removed or modified without breaking the cryptographic chain. This
means that information about previous verification methods, services, or
other metadata remains permanently visible in the log even after being
removed from the current [=DID document=]. This immutability can be problematic
for privacy if sensitive information was inadvertently included in earlier
versions of the [=DID document=], or if the history of changes itself reveals
sensitive information about the [=DID controller=]'s activities or relationships.
        </p>

        <p>
To address the immutability concern, implementers might exercise caution
when including information in [=DID documents=], as any data added will become
part of the permanent record. Before performing operations, carefully review
the information being added to ensure it does not contain sensitive data that
needs to remain private. For cases where the historical record becomes
problematic, [=DID controllers=] can deactivate the current DID and create a new
one, though this breaks continuity and requires updating all systems that
reference the old DID. Alternatively, implement clear documentation and
guidelines for [=DID controllers=] about what information might and might not
be included in [=DID documents=] to prevent privacy issues before they occur.
        </p>
      </section>

      <section>
        <h3>DID Identifier Persistence</h3>

        <p>
A DID identifier in the `did:cel` method is derived from or includes
cryptographic material from the initial creation event, making it a persistent
[=self-certifying identifier=] that is correlatable across all uses. Unlike some
privacy-preserving identifier systems that allow for easy rotation or unlinkable
presentations, a `did:cel` identifier remains constant and serves as a permanent
correlation point. Any entity that observes the DID identifier in multiple contexts
can definitively link those interactions as involving the same [=DID controller=].
This persistence is valuable for establishing long-term identity and trust
but directly conflicts with privacy goals that require unlinkability between
different interactions or contexts.
        </p>

        <p>
For scenarios requiring unlinkability, implementers might not reuse the same
DID across different contexts or relationships. Instead, create separate [=DIDs=]
for different purposes, relationships, or contexts where correlation might
be prevented. Implement DID management practices that include regular
rotation of [=DIDs=] when appropriate, and clearly document which [=DIDs=] are used
for which purposes. Organizations might also provide tooling to help users
manage multiple [=DIDs=] and understand the privacy implications of DID reuse.
For use cases where both persistence and privacy are required, consider
layering additional privacy-preserving mechanisms on top of the DID
infrastructure, such as using [=verifiable credentials=] with unlinkable
presentation features.
        </p>
      </section>

      <section>
        <h3>Verification Method Enumeration</h3>

        <p>
DID documents contain verification methods that specify the cryptographic
keys and their purposes (authentication, assertion, key agreement, etc.). The
complete set of verification methods, their types, cryptographic algorithms,
and relationship assignments can serve as a unique fingerprint for a DID,
especially when non-standard cryptographic suites are used or when the
combination of verification methods is unusual. Even when using common
cryptographic suites, the specific number and configuration of verification
methods for different purposes can reveal information about the DID
controller's intended use cases, security posture, or organizational
structure.
        </p>

        <p>
To reduce the identifiability of [=DIDs=] through verification method
enumeration, implementers might favor standard, commonly used verification
method configurations that are widely deployed in the ecosystem. Avoid
creating unique or unusual combinations of verification methods unless
specifically required. When possible, use the minimum number of verification
methods necessary for the intended functionality to reduce the uniqueness of
the configuration. For organizations deploying multiple [=DIDs=], consider
standardizing on common verification method templates that are used across
many [=DIDs=] to prevent fingerprinting. Documentation might also guide users on
recommended verification method configurations that balance functionality
with privacy considerations.
        </p>
      </section>

      <section>
        <h3>Service Endpoint Disclosure</h3>

        <p>
DID documents can include service endpoints that specify how to interact with
services related to the [=DID controller=]. These service endpoints often contain
URLs or other network identifiers that reveal information about the DID
controller's infrastructure, service providers, or operational environment.
Service endpoints might point to specific servers, domains, or third-party
services, which can be used to correlate [=DIDs=], identify the organizations or
individuals behind them, or map out relationships between different entities.
Even when service endpoints use common infrastructure, the specific
combination or configuration of services can serve as a identifying
characteristic.
        </p>

        <p>
Implementers might carefully consider whether service endpoints need to be
included in the [=DID document=] itself, or whether they could be communicated
through other channels that provide better privacy properties. When service
endpoints might be included, use generic or shared infrastructure that does
not reveal specific information about the [=DID controller=]. Consider using
privacy-preserving relay services, proxy servers, or shared service
infrastructure that is used by multiple entities to prevent correlation.
Avoid including service endpoints that point to unique or rarely used
domains. For higher privacy scenarios, service endpoint information might be
exchanged out-of-band or through encrypted communication channels rather than
being published in the public [=DID document=].
        </p>
      </section>

      <section>
        <h3>Witness Service Metadata</h3>

        <p>
When [=witness=] services attest to [=CEL=] events, they create proofs that include
metadata such as their [=witness=] identifier, the cryptographic suite used, and
potentially timing information. While this metadata is necessary for
verification, it can also reveal information about the [=DID controller=]'s
relationships with [=witness=] services, their [=witness=] selection strategy, and
potentially their geographic location or operational preferences. If a DID
consistently uses [=witnesses=] that are associated with specific geographic
regions, industries, or organizations, this association can reveal
information about the [=DID controller=]. Additionally, the specific combination
of [=witness=] services chosen might reveal business relationships or trust
relationships that the [=DID controller=] has established.
        </p>

        <p>
To mitigate privacy concerns related to [=witness=] metadata, implementers might
select [=witness=] services that are widely used and geographically distributed
to avoid revealing location information. When possible, use [=witness=] services
that are operated by neutral, well-known entities rather than
industry-specific or organization-specific [=witnesses=] that might reveal
affiliations. Consider implementing [=witness=] rotation policies that vary the
set of [=witnesses=] used across different operations to prevent long-term
correlation. Documentation might guide users on selecting [=witness=] services
that align with their privacy requirements, and ecosystems might encourage
the deployment of diverse, broadly available [=witness=] services that can be
used interchangeably to enhance herd privacy.
        </p>
      </section>

      <section>
        <h3>Long-term Cryptographic Commitment</h3>

        <p>
The cryptographic algorithms and key types chosen during DID creation and
throughout the DID's lifecycle represent long-term commitments that are
permanently recorded in the [=CEL=]. These cryptographic choices can reveal
information about when the DID was created (based on algorithm popularity at
that time), the security requirements or preferences of the [=DID controller=],
and potentially the systems or software used to create the DID. As
cryptographic algorithms age and new algorithms are adopted, the continued
use of older algorithms or the early adoption of newer ones can serve as
identifying characteristics. Furthermore, the cryptographic choices reveal
the [=DID controller=]'s security posture and risk tolerance.
        </p>

        <p>
Implementers might provide clear guidance on recommended cryptographic
algorithms that balance security requirements with privacy considerations.
Using widely adopted, current best-practice cryptographic algorithms helps
provide herd privacy by ensuring that many [=DIDs=] share similar cryptographic
profiles. Organizations might plan for cryptographic agility by supporting
algorithm migration paths that allow updating to newer algorithms without
requiring DID replacement. When upgrading cryptographic algorithms,
coordinate with broader ecosystem adoption to avoid standing out as an early
or late adopter. Documentation might explain the privacy implications of
different cryptographic choices and provide recommendations for standard
configurations that are appropriate for different use cases.
        </p>
      </section>

      <section>
        <h3>Resolution Privacy</h3>

        <p>
Resolving a DID to obtain its current [=DID document=] and verify the [=CEL=]
requires accessing the log data, which might be stored in various locations
such as distributed ledgers, decentralized storage systems, or centralized
repositories. The act of resolving a DID can reveal information about the
resolver's interest in that particular DID to the entities operating the
storage or retrieval infrastructure. This creates potential for surveillance,
tracking of resolution patterns, or profiling of which [=DIDs=] are being
resolved by which entities. Network-level metadata such as IP addresses,
timing of resolution requests, and patterns of correlated resolutions can
further compromise privacy by revealing resolver identity or activities.
        </p>

        <p>
To enhance resolution privacy, implementers might use privacy-preserving
resolution mechanisms such as proxies, VPNs, or onion routing when resolving
DIDs. Aggressive caching of [=DID documents=] and [=CEL=] data reduces the frequency
of resolution requests and limits the metadata exposed to storage providers.
Consider using decentralized resolution infrastructure that does not rely on
single points that can monitor resolution patterns. Implement resolution
protocols that minimize metadata leakage, such as fetching data through
encrypted channels or using obfuscation techniques that prevent correlation
of multiple resolution requests. For high-privacy scenarios, design systems
that pre-fetch or batch resolve multiple [=DIDs=] to obscure which specific [=DIDs=]
are of interest, and utilize privacy-preserving query protocols where
available.
        </p>
      </section>

    </section>

    <section class="informative">
      <h2>Security Considerations</h2>

      <p>
This section contains a variety of security considerations that people using
the `did:cel` Method are advised to consider before deploying this
technology in a production setting. Readers are urged to read the
<a data-cite="?CID#security-considerations">Security Considerations</a> section
of the [[[CID]]] specification, as well as the
<a data-cite="?DID#security-considerations">Security Considerations</a> section
of the [[[DID]]] specification, before reading this section.
      </p>

      <section>
        <h3>Witness Collusion and Compromise</h3>

        <p>
The security of the [=cryptographic event log=] relies on [=witness=] services
providing independent attestations to [=DID document=] operations. If a
sufficient number of [=witnesses=] collude or are compromised by an attacker,
they could attest to fraudulent events in the log, such as unauthorized
modifications to a [=DID document=] or attempts to fork the event history.
The impact of such an attack depends on how many [=witnesses=] are required for
an event to be considered valid and how many [=witnesses=] an attacker can
control. If [=witnesses=] are operated by a single entity or share common
infrastructure, the risk of coordinated compromise increases significantly.
        </p>

        <p>
To mitigate [=witness=] collusion risks, implementers are encouraged to select
[=witnesses=] operated by independent entities with diverse operational and
jurisdictional characteristics. Systems that verify [=DIDs=] can require
attestations from a minimum number of [=witnesses=] before accepting an event as
valid, and can maintain lists of trusted [=witnesses=] with known good security
practices. [=DID controllers=] are encouraged to select geographically and
organizationally distributed [=witnesses=] to minimize the risk of coordinated
attacks. Monitoring [=witness=] behavior over time can help detect anomalies that
might indicate compromise, such as [=witnesses=] consistently signing events that
other [=witnesses=] reject. For critical applications, implementing [=witness=]
rotation policies or requiring attestations from a larger pool of [=witnesses=]
can provide additional security margins.
        </p>
      </section>

      <section>
        <h3>Key Rotation and Revocation</h3>

        <p>
When a cryptographic key used in a [=DID document=] is compromised or needs
to be rotated for operational reasons, the [=DID controller=] faces the
challenge of updating the [=DID document=] while maintaining the integrity
and verifiability of the [=cryptographic event log=]. The key rotation process
itself requires signing operations using existing keys, but if those keys are
compromised, an attacker might perform unauthorized rotations before the
legitimate [=DID controller=] can act. Additionally, the immutable nature of
the log means that compromised keys remain visible in the historical record,
potentially allowing attackers to forge signatures on historical [=DID
documents=] if proper expiration handling is not implemented.
        </p>

        <p>
Implementers are encouraged to implement key expiration mechanisms using the
`expires` property on [=verification methods=], which limits the time window
during which a compromised key can be abused. When rotating keys, [=DID
controllers=] are advised to follow a process of first adding new keys to the
[=DID document=], then expiring old keys, and only after confirming the new
keys are functional should the old keys be removed. This overlapping approach
ensures continuity of operations during rotation. For critical keys,
maintaining offline backup keys with authority to perform emergency rotations
can provide recovery paths when primary keys are compromised. Systems that
verify [=data integrity proofs=] are encouraged to check expiration times and
reject proofs created after a [=verification method=] has expired, limiting
the damage from compromised keys. Regular key rotation schedules, even
without evidence of compromise, can reduce the impact window of undetected
key compromises.
        </p>
      </section>

      <section>
        <h3>Hash Collision Resistance</h3>

        <p>
The `did:cel` method relies on SHA3-256 cryptographic hashing for multiple
security-critical functions: generating [=DID=] identifiers from [=DID
documents=], creating hash links between events in the [=cryptographic event
log=], and ensuring the integrity of the event chain. If SHA3-256 were to
become vulnerable to collision attacks where two different inputs produce the
same hash output, attackers could create fraudulent [=DID documents=] that
resolve to the same [=DID=] identifier, forge event chain links to hide
modifications, or substitute malicious events while maintaining apparent
chain integrity. The security of the entire [=DID=] method depends on the
continued collision resistance of SHA3-256.
        </p>

        <p>
While SHA3-256 is currently considered cryptographically secure with no
known practical collision attacks, implementers are advised to monitor
cryptographic research for any developments that might weaken SHA3-256.
Systems can be designed with cryptographic agility in mind, allowing for
future migration to stronger hash functions if SHA3-256 becomes compromised.
When verifying [=DIDs=], implementations are encouraged to validate not just
that hash links are correctly formed, but also that the entire chain of
events maintains integrity from the creation event forward. For long-lived
[=DIDs=], [=DID controllers=] might consider planning for eventual migration
to new [=DIDs=] using stronger cryptographic primitives before SHA3-256
reaches end of life, though the timeline for such migrations is measured in
decades given current cryptographic knowledge.
        </p>
      </section>

      <section>
        <h3>Replay Attack Prevention</h3>

        <p>
Events in the [=cryptographic event log=] contain [=data integrity proofs=] and
[=witness=] attestations that are valid cryptographic signatures. Without proper
safeguards, an attacker might capture a valid event from one [=DID=]'s log
and attempt to replay it in a different context, such as in another [=DID=]'s
log or at a different position in the same log. While the [=hashlinking=]
mechanism provides some protection by binding events to specific positions in
the chain, attackers might attempt to fork a log at an earlier point and
replay captured events to create a fraudulent alternate history. The
self-contained nature of events means that signatures remain mathematically
valid even when presented out of their intended context.
        </p>

        <p>
The [=hashlinking=] of events through the `previousEvent` property provides the
primary defense against replay attacks by binding each event to a specific
position in the event chain. Implementations that verify [=cryptographic event
logs=] are advised to validate that each event's `previousEvent` hash correctly
matches the hash of the preceding event, and that the chain is unbroken from
the creation event to the most recent event. [=Witness=] proofs are encouraged to
include additional context-binding information such as the [=DID=] identifier
being attested to, which prevents events from being replayed across different
[=DIDs=]. For applications requiring stronger replay protection, events can
include timestamps or sequence numbers that are validated during
verification, though this introduces additional complexity and potential for
timing-based attacks. Systems that maintain state about known [=DIDs=] can
track the highest event sequence number they have seen for each [=DID=] and
reject events that appear to rewind the log.
        </p>
      </section>

      <section>
        <h3>Event Ordering and Forking</h3>

        <p>
The [=cryptographic event log=] creates a linear chain of events through
[=hashlinking=], but without additional coordination mechanisms, a [=DID
controller=] or an attacker with access to the [=DID controller=]'s keys
could create multiple divergent chains (forks) from the same parent event.
This could result in different observers seeing different versions of the
[=DID document=] depending on which fork they have accessed. While [=witness=]
services provide some protection by refusing to attest to events that fork
from previously [=witnessed=] chains, a compromised or malicious [=DID
controller=] might selectively present different forks to different [=witnesses=]
or observers, creating confusion about the authoritative state of the [=DID
document=].
        </p>

        <p>
Detecting forks requires observers to compare event logs from multiple
sources and identify cases where divergent chains exist for the same [=DID=].
[=Witness=] services are encouraged to maintain persistent records of all events
they have attested to and refuse to sign events that would create a fork from
a previously [=witnessed=] chain. Implementations that resolve [=DIDs=] can query
multiple independent sources for the event log and flag any cases where
inconsistent histories are detected. For critical applications, [=DID
controllers=] might publish commitments to their event log in external
transparency logs or blockchain systems, making forks detectable by any
observer. The [=witness=]-based architecture provides distributed verification,
but ultimately relies on [=witnesses=] maintaining integrity and rejecting fork
attempts. Clear policies about how [=witnesses=] handle fork detection, including
whether they alert other [=witnesses=] or [=DID=] observers, can strengthen the
overall security posture against forking attacks.
        </p>
      </section>

      <section>
        <h3>Proof Verification Requirements</h3>

        <p>
Each event in a [=cryptographic event log=] contains [=data integrity proofs=]
on the [=DID document=] and potentially multiple [=witness=] proofs attesting to
the event. Verifying the complete log requires checking every proof in every
event from the creation event forward, which involves cryptographic signature
verification operations, hash computations, and canonicalization of JSON-LD
data structures. For [=DIDs=] with long histories containing many events and
[=witness=] proofs, the computational cost of full verification can be
substantial, potentially leading to resource exhaustion or denial-of-service
conditions when processing maliciously crafted logs with excessive events or
complex proof structures.
        </p>

        <p>
Implementations are encouraged to set reasonable limits on the resources
they will expend when verifying [=cryptographic event logs=], including maximum
numbers of events to process, maximum verification time, and maximum memory
usage. When possible, verification can be optimized by caching the results of
verifying earlier portions of the log and only verifying new events since the
last cached verification point. For applications that do not require complete
historical verification, implementations might verify only the most recent
events and rely on the [=witness=] attestations as evidence that earlier events
were valid at the time they were created. Rate limiting the acceptance of
[=DID=] resolution requests can prevent attackers from overwhelming systems
with verification requests for complex [=DIDs=]. Clear documentation about
the expected verification costs and performance characteristics helps
implementers make informed decisions about resource allocation for [=DID=]
verification operations.
        </p>
      </section>

      <section>
        <h3>Witness Availability and Reliability</h3>

        <p>
The [=witness=]-based architecture of `did:cel` creates an operational dependency
on [=witness=] services being available and responsive when [=DID controllers=]
need to update their [=DID documents=]. If [=witnesses=] become unavailable due
to network outages, operational failures, or deliberate denial-of-service
attacks, [=DID controllers=] might be unable to record new events in their
[=cryptographic event logs=], effectively preventing them from making necessary
updates such as key rotations in response to security incidents. This
availability dependency could be exploited by attackers who compromise a
[=DID controller=]'s keys and then launch denial-of-service attacks against
[=witness=] services to prevent the legitimate controller from performing
emergency key rotations.
        </p>

        <p>
[=DID controllers=] are encouraged to select multiple geographically and
operationally distributed [=witnesses=] to reduce the risk of correlated
failures. Systems can be designed to tolerate some [=witness=] unavailability by
requiring only a subset of [=witnesses=] to attest to an event, though this
reduces the security assurance provided by [=witness=] attestations.
Implementing [=witness=] selection policies that automatically failover to
alternative [=witnesses=] when primary [=witnesses=] are unavailable can maintain
operational continuity during outages. For critical operations, [=DID
controllers=] might pre-establish relationships with backup [=witness=] services
that can be used if primary [=witnesses=] fail. [=Witness=] services are encouraged
to implement high-availability architectures with redundancy and failover
capabilities to minimize downtime. Clear service level agreements and
monitoring of [=witness=] availability helps [=DID controllers=] make informed
decisions about which [=witnesses=] to rely on for their security requirements.
        </p>
      </section>

      <section>
        <h3>Cryptographic Algorithm Aging</h3>

        <p>
The `did:cel` method uses ECDSA with P-256 curves for [=verification
methods=] and [=data integrity proofs=], and SHA3-256 for hashing operations.
While these cryptographic algorithms are currently considered secure, all
cryptographic algorithms have a finite lifetime and eventually become
vulnerable to attacks as computational capabilities advance or new
cryptographic breakthroughs occur. [=DIDs=] created today might need to
remain valid and verifiable for many years or decades, potentially outliving
the security guarantees of the cryptographic algorithms they employ. As
algorithms age, signatures and hashes created using those algorithms provide
diminishing security, but the immutable nature of the [=cryptographic event log=]
means historical events cannot be re-signed with stronger algorithms.
        </p>

        <p>
[=DID controllers=] planning for long-term use of their [=DIDs=] are
encouraged to monitor cryptographic algorithm recommendations and plan for
eventual migration to [=DIDs=] using stronger algorithms before current
algorithms are compromised. Implementing cryptographic layering by including
multiple [=verification methods=] using different cryptographic algorithms
can provide continued security even if one algorithm is compromised,
following the guidance in the Data Integrity specification. Systems that
verify [=DIDs=] can maintain policies about which cryptographic algorithms
are acceptable and reject [=DIDs=] using deprecated algorithms that no longer
provide adequate security. For historical preservation, the [=witness=]
attestations in the log provide evidence that events were considered valid at
the time they were created, even if the underlying cryptographic algorithms
later become compromised. Clear documentation about the expected lifetime of
cryptographic algorithms helps [=DID controllers=] plan appropriate migration
timelines.
        </p>
      </section>

      <section>
        <h3>Timestamp Manipulation</h3>

        <p>
[=Witness=] [=data integrity proofs=] might include timestamp information
indicating when the [=witness=] attested to an event. While timestamps can be
useful for understanding the temporal sequence of events and detecting
anomalies, they also introduce potential for manipulation if [=witnesses=]
collude or if their clocks are inaccurate or maliciously adjusted. An
attacker who compromises multiple [=witnesses=] might create backdated
attestations to make fraudulent events appear to have occurred earlier than
they actually did, or forward-date attestations to hide the timing of
malicious activities. Relying on timestamps for security-critical decisions
can be problematic given the difficulty of ensuring accurate, tamper-proof
time sources across distributed [=witness=] services.
        </p>

        <p>
Implementations are encouraged to use timestamps as informational indicators
rather than security-critical values, and to corroborate timing information
from multiple independent sources before relying on it. When [=witnesses=]
include timestamps in their proofs, using multiple [=witnesses=] with independent
time sources can help detect significant clock discrepancies or manipulation
attempts. Systems that detect large discrepancies in [=witness=] timestamps for
the same event can flag those events for additional scrutiny. For
applications requiring strong temporal guarantees, consider anchoring events
to external time-stamping authorities or blockchain systems that provide
verifiable proof of time. The [=hashlinked=] structure of the event log provides
a partial ordering guarantee—events must have occurred in the order they
appear in the chain—which can be more reliable than timestamp values for
determining relative event ordering. Clear documentation about the limitations
of timestamp information helps prevent over-reliance on timing data that
might be manipulated.
        </p>
      </section>

      <section>
        <h3>Storage and Retrieval Security</h3>

        <p>
[=cryptographic event logs=] need to be stored and made available for [=DID=]
resolution, but the specification does not mandate a particular storage
mechanism. Depending on the chosen storage approach—whether distributed
ledgers, decentralized storage systems, centralized repositories, or peer-to-peer
networks—different security considerations apply. If log storage is
compromised, attackers might delete events to hide malicious modifications,
modify historical events to change the [=DID document=] history, or deny
access to legitimate log data preventing [=DID=] resolution. The integrity
and availability of the storage system directly impacts the security and
usability of the [=DID=].
        </p>

        <p>
[=DID controllers=] are encouraged to store their [=cryptographic event logs=] in
multiple independent locations to protect against data loss and ensure
availability even if one storage location fails or is compromised. The
[=hashlinked=] structure and [=witness=] proofs in the log provide integrity
protection, meaning that modifications to stored log data can be detected
during verification, but this does not prevent deletion or denial of access.
Using storage systems with built-in redundancy, access controls, and audit
logging can help protect log data from unauthorized modification or deletion.
For public [=DIDs=], publishing logs to multiple publicly accessible
repositories or content-addressed storage systems increases resilience and
makes censorship more difficult. Implementations that retrieve logs are
encouraged to verify the complete integrity of the log using the [=hashlinking=]
and proofs, rather than trusting that stored data is authentic. Backup
strategies that maintain copies of logs in geographically and operationally
diverse locations can ensure long-term preservation and availability.
        </p>
      </section>

      <section>
        <h3>DID Document Proof Validation</h3>

        <p>
Each [=DID document=] in the [=cryptographic event log=] contains a [=data
integrity proof=] that cryptographically binds the document to the [=DID
controller=] through a signature created with a [=verification method=]
contained in the document. Proper validation of these proofs is critical for
security—if implementations skip proof verification or perform it
incorrectly, they might accept fraudulent [=DID documents=] that were not
actually created by the legitimate [=DID controller=]. The complexity of
[=data integrity proof=] verification, which involves JSON-LD processing,
canonicalization, and signature verification, creates opportunities for
implementation errors that could compromise security.
        </p>

        <p>
Implementations are strongly encouraged to use well-tested, standardized
libraries for [=data integrity proof=] verification rather than implementing
verification logic from scratch, as cryptographic implementations are prone
to subtle errors that can completely compromise security. Following the
verification algorithms specified in the Data Integrity specification
precisely, without shortcuts or optimizations that might skip critical
validation steps, is important for maintaining security. Verification
processes are encouraged to validate all aspects of the proof including the
signature value, the proof purpose, the verification method reference, and
any additional proof metadata. Regular testing with both valid and
intentionally malformed proofs can help ensure that implementations correctly
reject invalid proofs. Implementers are advised to review the security
considerations in the Data Integrity specification for additional guidance on
proof verification.
        </p>
      </section>

      <section>
        <h3>Previous Event Hash Verification</h3>

        <p>
The integrity of the [=cryptographic event log=] depends on each event
containing a correct hash of the previous event in the `previousEvent`
property, creating an unbroken chain from the creation event to the most
recent event. If implementations fail to properly verify that each
`previousEvent` hash matches the actual hash of the preceding event, or if
they skip hash verification entirely, attackers could insert fraudulent
events, remove events from the middle of the chain, or create alternate
histories without detection. This [=hashlinking=] is fundamental to the security
model—without rigorous verification, the log provides no integrity guarantees.
        </p>

        <p>
Implementations that verify [=cryptographic event logs=] are advised to compute
the hash of each event using the same canonicalization and hashing algorithms
specified in the creation and update algorithms, and verify that the computed
hash matches the `previousEvent` value in the following event. Verification
processes are encouraged to validate the complete chain from the creation
event forward without skipping any events, as gaps in verification could hide
inserted or modified events. The creation event, which has no previous event,
represents a trust anchor and its authenticity can be verified through [=witness=]
attestations and the [=data integrity proof=] on the [=DID document=]. For
performance reasons, implementations might cache verification results for
earlier portions of the chain, but care is needed to ensure cached results are
not reused when the log has been modified. Clear error handling and reporting
when hash verification fails helps diagnose attacks or data corruption issues.
        </p>
      </section>

      <section>
        <h3>Witness Proof Threshold Requirements</h3>

        <p>
The `did:cel` specification includes [=witness=] attestations for events but does
not mandate how many [=witness=] proofs are required for an event to be
considered valid or trustworthy. Different applications and trust models
might require different numbers of [=witnesses=]—some might accept events with a
single [=witness=] attestation, while others might require unanimous agreement
from multiple [=witnesses=]. If the threshold is set too low, attackers who
compromise a small number of [=witnesses=] can attest to fraudulent events. If
set too high, legitimate operations might be blocked by [=witness=] unavailability
or disagreement, creating denial-of-service conditions.
        </p>

        <p>
Implementations are encouraged to establish clear policies about [=witness=]
proof requirements that balance security needs against operational
flexibility. For high-security applications, requiring attestations from a
majority or supermajority of a defined [=witness=] set provides protection
against individual [=witness=] compromises. Lower-security applications might
accept events with fewer attestations but implement monitoring to detect
suspicious patterns. Policies can be adaptive, such as requiring more
[=witnesses=] for security-critical operations like key rotations while accepting
fewer [=witnesses=] for routine updates. When [=witnesses=] disagree about an event's
validity, implementations are encouraged to investigate the discrepancy rather
than automatically accepting or rejecting the event. Clear documentation
about [=witness=] requirements helps [=DID controllers=] understand what level of
[=witness=] consensus they need to achieve for their operations to be accepted by
verifiers. [=Witness=] selection strategies that include [=witnesses=] with diverse
operational and governance models can provide more robust validation than
[=witnesses=] operated by related entities.
        </p>
      </section>

      <section>
        <h3>Unauthorized DID Modifications</h3>

        <p>
The security of [=DID document=] modifications relies on the [=DID
controller=] maintaining exclusive control over the private keys corresponding
to [=verification methods=] in the [=DID document=]. If an attacker gains
access to these private keys through theft, social engineering, malware, or
cryptographic compromise, they can create fraudulent updates to the [=DID
document=] that appear legitimate because they carry valid [=data integrity
proofs=]. Such unauthorized modifications might add attacker-controlled
[=verification methods=], remove legitimate verification methods, change
service endpoints, or modify other [=DID document=] properties, all while
appearing to be authorized changes in the [=cryptographic event log=].
        </p>

        <p>
[=DID controllers=] are strongly encouraged to implement rigorous key
management practices including secure generation, storage, and access control
for private keys. Using hardware security modules, secure enclaves, or other
tamper-resistant storage for keys that control critical [=DIDs=] can
significantly reduce the risk of key theft. Multi-signature schemes where
multiple keys are required to authorize modifications can prevent a single
compromised key from enabling unauthorized updates. Regular security audits,
monitoring for unexpected [=DID document=] changes, and maintaining offline
backups of key material can help detect and recover from compromises.
Implementing the principle of least privilege by using different
[=verification methods=] for different purposes, with only minimal keys
having authority to modify the [=DID document=], can limit the impact of key
compromises. When unauthorized modifications are detected, rapid key rotation
following the guidance in the key rotation section can help regain control
and prevent further unauthorized changes.
        </p>
      </section>

      <section>
        <h3>Cryptosuite Downgrade Attacks</h3>

        <p>
As cryptographic algorithms age and newer, stronger algorithms become
available, [=DID documents=] might contain [=verification methods=] using
different cryptographic suites with varying security strengths. An attacker
might attempt to force systems to use weaker cryptographic algorithms by
selectively removing stronger [=verification methods=] from [=DID documents=]
they present to verifiers, or by exploiting verification implementations that
default to weaker algorithms when multiple options are available. If
successful, such downgrade attacks reduce the effective security to that of
the weakest algorithm, potentially enabling signature forgeries or other
cryptographic breaks that would not be possible against stronger algorithms.
        </p>

        <p>
Implementations are encouraged to maintain policies about which cryptographic
algorithms are acceptable and to reject [=DID documents=] or proofs using
algorithms that no longer provide adequate security. When [=DID documents=]
contain multiple [=verification methods=] using different algorithms,
verification processes are advised to require proofs using the strongest
available algorithm rather than accepting proofs from any method. [=DID
controllers=] are encouraged to remove deprecated [=verification methods=]
using obsolete algorithms from their [=DID documents=] once stronger methods
are in place, rather than maintaining weak methods for backward compatibility.
Clear documentation about supported cryptographic algorithms and their
expected security lifetimes helps both [=DID controllers=] and verifiers make
informed decisions about algorithm selection. Following the cryptographic
agility guidance in the Data Integrity specification enables smooth
transitions to newer algorithms without compromising security during
migration periods.
        </p>
      </section>

    </section>

  </section>

  <section class="appendix informative">
    <h2>Acknowledgements</h2>

    <p>
The Working Group would like to thank the following individuals for reviewing
and providing feedback on the specification (in alphabetical order):
    </p>

    <p>
TBD...
    </p>
  </section>
  </body>
</html>

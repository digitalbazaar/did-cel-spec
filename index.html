<!DOCTYPE html>
<html>
  <head>
    <title>The did:cel Method v0.3</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
    <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove'></script>
    <script src="https://cdn.jsdelivr.net/gh/digitalbazaar/respec-vc@3.4.2/dist/main.js" class="remove"></script>
    <script type="text/javascript" class="remove">
      var respecConfig = {
        // specification status (e.g., WD, LCWD, NOTE, etc.). If in doubt use ED.
        specStatus: "CG-DRAFT",

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName: "did-cel",

        // subtitle for the spec
        subtitle: "A DID Method based on witnessed cryptographic event logs",

        // if you wish the publication date to be other than today, set this
        //publishDate: "",
        //crEnd: "",
        //prEnd: "",
        //implementationReportURI: "",

        // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
        // and its maturity status
        // previousPublishDate:  "1977-03-15",
        // previousMaturity:  "WD",

        // extend the bibliography entries
        localBiblio: {
          'THORMARKER': {
            title: 'On using the same key pair for Ed25519 and an X25519 based KEM',
            href: 'https://eprint.iacr.org/2021/509.pdf',
            authors: ['Erik Thormarker'],
            status: 'Internet-Draft',
            publisher: 'Cryptology ePrint Archive'
          }
        },
        doJsonLd: true,

        github: "https://github.com/w3c-ccg/did-cel-spec",
        includePermalinks: false,

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: "https://w3c-ccg.github.io/did-cel-spec/",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // editors, add as many as you like
        // only "name" is required
        editors: [
          { name: "Manu Sporny", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/" }
        ],
        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.
        authors:
        [
          { name: "Dave Longley", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/"},
          { name: "Manu Sporny", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/" }
        ],
        group: 'credentials',

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI from a random
        // document unless you know what you're doing. If in doubt ask your friendly neighborhood
        // Team Contact.
        wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/98922/status",
        maxTocLevel: 2,
        inlineCSS: true,
        postProcess: [],
        xref: [
          "infra", "web-platform", "cid", "did", "vc-data-model",
          "vc-data-integrity"
        ],
        lint: {
          "informative-dfn": false
        },
        otherLinks: [{
          key: "Related Documents",
          data: [{
            value: "Controlled Identifiers v1.0",
            href: "https://www.w3.org/TR/cid/"
          }, {
            value: "Decentralized Identifiers v1.0",
            href: "https://www.w3.org/TR/did/"
          }, {
            value: "DID Use Cases and Requirements",
            href: "https://www.w3.org/TR/did-use-cases/"
          }, {
            value: "DID Core Implementation Report",
            href: "https://w3c.github.io/did-test-suite/"
          }]
        }]
      };
    </script>
    <style>
code {
  color: rgb(199, 73, 0);
  font-weight: bold;
}
pre {
  overflow-x: auto;
  white-space: pre-wrap;
}
pre .highlight {
  font-weight: bold;
  color: Green;
}
pre .subject {
  font-weight: bold;
  color: RoyalBlue;
}
pre .property {
  font-weight: bold;
  color: DarkGoldenrod;
}
pre .comment {
  font-weight: bold;
  color: SteelBlue;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
ol.algorithm { counter-reset:numsection; list-style-type: none; }
ol.algorithm li { margin: 0.5em 0; }
ol.algorithm li:before { font-weight: bold; counter-increment: numsection; content: counters(numsection, ".") ") "; }

table.simple {
    border-collapse: collapse;
    margin: 25px 0;
    min-width: 400px;
    border: 1px solid #dddddd;
}
table.simple thead tr {
    background-color: #005a9c;
    color: #ffffff;
    text-align: left;
}
table.simple th,
table.simple td {
    padding: 12px 15px;
    vertical-align: top;
    text-align: left;
}
table.simple tbody tr {
    border-bottom: 1px solid #dddddd;
}
table.simple tbody tr:nth-of-type(even) {
    background-color: #00000008;
}
table.simple tbody tr:last-of-type {
    border-bottom: 2px solid #005a9c;
}
    </style>
  </head>
  <body>
    <section id='abstract'>
      <p>
[=Decentralized Identifiers=] (DIDs) are a type of identifier for verifiable,
decentralized digital identity. These identifiers are designed to enable the
[=controller=] of a DID to prove control over the identifier in a way that is
independent of any centralized registry, identity provider, or certificate authority.
These sorts of identifiers often utilize a heavy-weight registry, such as ones
utilizing Decentralized Ledger Technologies (DLT), to create, read, update,
and deactivate [=DIDs=]. This specification describes a witness-based [=DID
Method=] where each DID Document's history is contained in a cryptographic
event log where each event is witnessed by one or more trusted entities. The
approach avoids the need for complex decentralized consensus algorithms as well
as expensive proof-of-work or proof-of-stake systems.
      </p>
    </section>

    <section id='sotd'>

      <p>
      </p>

    </section>

    <section class="informative">
      <h2>Introduction</h2>

      <section id="conformance"></section>

    </section>

    <section class="normative">
      <h2>did:cel Identifier Syntax</h2>

      <p>
The format for the `did:cel` method conforms to the [[[DID]]] specification and
is simple. It consists of the `did:cel` prefix, followed by a <a
data-cite="CID#Multibase">Multibase</a> base58-btc encoded value
that is a concatenation of the <a data-cite="CID#Multihash">Multihash</a>
identifier and the corresponding cryptographic digest for the initial
cryptographic event log entry.
      </p>

      <p>
The ABNF for the key format is described below:
      </p>

      <pre>
did-cel-format := did:cel:&lt;mb-value>
mb-value       := z[a-km-zA-HJ-NP-Z1-9]+
      </pre>

      <p>
Alternatively, the encoding rules can also be thought of as the application
of a series of transformation functions on the raw public key bytes:
      </p>

      <tt>
did-cel-identifier := did:cel:MULTIBASE(base58-btc, MULTICODEC(sha3-256, JCS(initial-event-log-entry)))
      </tt>

      <p>
A simple example of a valid `did:cel` DID is:
      </p>

      <pre class="example nohighlight" title="A valid did:cel identifier">
did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE
      </pre>

    </section>

    <section class="normative">
      <h2>Operations</h2>

      <p>
The following section outlines the DID operations for the `did:cel` method.
      </p>

      <section class="normative">
        <h3>Create</h3>

        <p>
The create operation establishes a new `did:cel` [=DID document=] with a
self-certifying identifier derived from the document's cryptographic hash. This
operation generates an initial cryptographic key pair, constructs a [=DID document=] containing
the public key as an assertion method, and adds a [=data integrity proof=] to
the document. This approach ensures that the [=DID=] is intrinsically
bound to the document's initial state, providing strong integrity guarantees
without requiring external registration.
        </p>

        <p>
Once the [=DID document=] is created and signed, a Cryptographic Event Log (CEL) is
initialized to track the complete history of operations on this DID. The log's
first entry is a `create` event that contains the signed [=DID document=] as its
data payload. This event serves as the cryptographic foundation for all
subsequent updates, enabling verifiable audit trails and witness attestation.
The combination of the self-certifying identifier, cryptographic proof, and
event log creates a decentralized identifier implementation that requires no
centralized authority for creation, validation, or resolution.
        </p>

        <p>
An example of a cryptographic event log containing the creation event for a
`did:cel` [=DID=] is shown below.
        </p>

        <pre class="example nohighlight" title="Cryptographic event log after did:cel creation">
{
  "log": [
    {
      "event": {
        "operation": {
          "type": "create",
          "data": {
            "@context": "https://www.w3.org/ns/did/v1.1",
            "id": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
            "assertionMethod": [
              {
                "id": "#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
              }
            ],
            "proof": {
              "type": "DataIntegrityProof",
              "cryptosuite": "ecdsa-jcs-2019",
              "created": "2025-12-03T12:41:21Z",
              "proofPurpose": "assertionMethod",
              "proofValue": "z3Z2BFFtVSZPjFGipCazyD8CLp8U5ovw4Mvvk4SkvNL3dgXrAH3PMeTDvxJzS9wd9dUrxLCAr3c53t2CmnNbcgscd",
              "verificationMethod": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
            }
          }
        }
      }
    }
  ]
}
        </pre>

        <section class="normative">
          <h4>Document Creation Algorithm</h4>

          <p>
The following algorithm specifies how to create a new `did:cel` DID
document with an initial verification method and establish a cryptographic event
log. The algorithm takes an optional [=map=] |options| as input. The |options|
map MAY contain a |keyType| property specifying an cryptographic key type to use
(defaults to `P-256`). Output is a [=map=] containing the generated
|didDocument|, the associated |keyPair|, and the initial
|cryptographicEventLog|, or an error. Whenever this algorithm encodes strings,
it MUST use UTF-8 encoding.
          </p>

          <ol class="algorithm">
            <li>
Let |keyType| be set to |options|.|keyType| if present, otherwise set to
`P-256`. The |keyType| value MUST be a valid keyType identifier
supported by the <a data-cite="CID#Multikey">Multikey</a> specification.
            </li>
            <li>
Generate a new key pair based on |keyType|. Let |keyPair| be the result. If key
generation fails, an error MUST be raised and SHOULD convey an error type of
`KEY_GENERATION_ERROR`.
            </li>
            <li>
Export the public key from |keyPair| as a <a
data-cite="CID#Multikey">Multikey</a> value. Let |publicKey| be the result.
            </li>
            <li>
Create an initial [=DID document=] structure ([=map=] |didDocument|) with the
following properties:
              <ol class="algorithm">
                <li>
Set |didDocument|.`@context` to the string
`"https://www.w3.org/ns/did/v1.1"`.
                </li>
                <li>
Set |didDocument|.`assertionMethod` to an array containing a single
verification method object with the following properties:
                  <ol class="algorithm">
                    <li>
Set the verification method's `id` value to the concatenation of the
`#` character and the `publicKeyMultibase` value of the |publicKey|.
                    </li>
                    <li>
Set the verification method's `type` to `Multikey`.
                    </li>
                    <li>
Set the verification method's `publicKeyMultibase` to
|publicKey|.`publicKeyMultibase`.
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>
Generate the [=DID=]by hashing the canonicalized [=DID document=]:
              <ol class="algorithm">
                <li>
Canonicalize |didDocument| using JSON Canonicalization Scheme (JCS) as specified
in [[RFC8785]]. Let |canonicalizedDidDocument| be the result.
                </li>
                <li>
Compute the SHA3-256 <a data-cite="CID#Multihash">Multihash</a> of the
UTF-8 encoded canonicalized document. Let |hash| be the result.
                </li>
                <li>
Encode |hash| using base58-btc encoding, prepending the
<a data-cite="CID#Multibase">Multibase</a> (`z`) character to the encoding. Let
|encodedHash| be the result.
                </li>
                <li>
Set |didDocument|.`id` to the concatenated value of `did:cel:` and
the |encodedHash|.
                </li>
                <li>
Set the `controller` property of the verification method in
|didDocument|.`assertionMethod` to |didDocument|.`id`.
                </li>
              </ol>
            </li>
            <li>
Generate a cryptographic proof for |didDocument| using a cryptosuite
that is compatible with the generated |keyPair|, such as
<a data-cite="VC-DI-ECDSA#ecdsa-jcs-2019">ecdsa-jcs-2019</a>. Set the
`proofPurpose` to `assertionMethod`. Add the `proof` to the |didDocument|.
            </li>
            <li>
Create the initial cryptographic event log:
              <ol class="algorithm">
                <li>
Create a new [=map=] |cryptographicEventLog| with a `log` property
set to an array containing a single event object.
                </li>
                <li>
The event object MUST contain an `event` property that is a [=map=]
with an `operation` property.
                </li>
                <li>
The `operation` [=map=] MUST contain:
                  <ol class="algorithm">
                    <li>
A `type` property with the value `create`.
                    </li>
                    <li>
A `data` property containing the complete |didDocument|.
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>
Return a [=map=] containing:
              <ol class="algorithm">
                <li>
|didDocument|: the completed [=DID document=] with the computed identifier
                </li>
                <li>
|keyPair|: the generated key pair (including secret key material)
                </li>
                <li>
|cryptographicEventLog|: the initial event log with the create event
                </li>
              </ol>
            </li>
          </ol>

        </section>

      </section>

      <section class="normative">
        <h3>Witness</h3>

        <p>
The witness operation provides independent cryptographic attestation for events
in a Cryptographic Event Log, establishing temporal evidence and distributed
validation of [=DID=] operations. After a [=DID document=] is modified, witness
services—independent entities operating under their own authority—generate
[=data integrity proofs=] over events in the log. Each witness returns a
cryptographic proof that attests the event existed and was witnessed at a
specific point in time.
        </p>

        <p>
The witnessing process does not modify the event itself; rather, it produces a
collection of cryptographic proofs that are attached to the event structure for
subsequent verification. These witness attestations serve multiple purposes:
they provide temporal anchoring by demonstrating when an event was witnessed,
enable auditability through independent third-party validation, and increase
resistance to tampering by distributing trust across multiple independent
witnesses. Unlike centralized timestamp authorities, the witness architecture
allows [=DID controllers=] to select witness services, preventing single points of
failure while maintaining cryptographic verifiability of the entire event
history.
        </p>

        <p class="issue" title="Witnesses create forking concerns">
It may be that in addition to witnesses, [=DID controllers=] might need to commit
to one or more systems that keep the latest cryptographic event log such that
any attempts at forking would be detectable. Dishonest [=DID controllers=], or
attackers that have compromised a [=DID controller=]'s cryptographic keys, might
create divergent histories to gain an advantage over a system that relies on
a particular DID. To prevent this attack, the [=DID controller=] would have to
establish one or more systems that always have the latest [=DID document=] to
prevent forking attacks.
        </p>

        <pre class="example nohighlight" title="Cryptographic event log after witnessing">
{
  "log": [
    {
      "@context": [
        "https://w3id.org/security/data-integrity/v2"
      ],
      "event": {
        "operation": {
          "type": "create",
          "data": {
            "@context": "https://www.w3.org/ns/did/v1.1",
            "id": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
            "assertionMethod": [
              {
                "id": "#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
              }
            ],
            "proof": {
              "type": "DataIntegrityProof",
              "cryptosuite": "ecdsa-jcs-2019",
              "created": "2025-12-03T12:41:21Z",
              "proofPurpose": "assertionMethod",
              "proofValue": "z3Z2BFFtVSZPjFGipCazyD8CLp8U5ovw4Mvvk4SkvNL3dgXrAH3PMeTDvxJzS9wd9dUrxLCAr3c53t2CmnNbcgscd",
              "verificationMethod": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
            }
          }
        }
      },
      "proof": [
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-03T12:44:32Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z5zybUDUyKkxgmHNYN8a3N4A33rKVv5pmnXHmHvbkXnkXrvfVFTSYNZxUr6C4QqEUoVdHJbtHykzVKr8rDLcE1zU9",
          "verificationMethod": "did:web:red-witness.example#vm-red-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-03T12:44:32Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z2c9Y4nBvGpQfyTzDcgmEjnVxaMTJNdPxfEmA8i4JwfVTe9jwRFQvSRSodEMqiVGwADMzW7dmqrAjecfm67nda7bW",
          "verificationMethod": "did:web:green-witness.example#vm-green-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-03T12:44:32Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z9QXFEcjThByMsLj5XbEmRwpzKh2318QvAhrM9V4Ddxni2mSgV1TW2e9J2Eqg4pQr9eWq3eBEa5gdGVon7Ba8d25",
          "verificationMethod": "did:web:blue-witness.example#vm-blue-1"
        }
      ]
    }
  ]
}
        </pre>

        <section class="normative">
          <h4>Document Witnessing Algorithm</h4>

          <p>
The following algorithm specifies how to generate witness attestations for the
most recent event in a Cryptographic Event Log. Witnesses are independent
entities that cryptographically sign events to provide decentralized validation
and auditability. The algorithm takes a [=map=] |cel| as input, which is the
Cryptographic Event Log containing one or more events. Output is an array of
proof objects, one from each configured witness, or an error. Whenever this
algorithm encodes strings, it MUST use UTF-8 encoding.
          </p>

          <ol class="algorithm">
            <li>
Initialize an empty array |proofs| to collect witness attestations.
            </li>
            <li>
Let |event| be the most recent event in |cel|.|log|. This is obtained by
accessing the last event in the array.
            </li>
            <li>
Let |witnesses| be an array of witness endpoint URLs that are trusted by the
controller of the [=DID=].
            </li>
            <li>
For each |witness| endpoint in |witnesses|, perform the following steps:
              <ol class="algorithm">
                <li>
Canonicalize |event| using the JSON Canonicalization Scheme (JCS) as specified
in [[RFC8785]]. Let |canonicalizedEvent| be the result.
                </li>
                <li>
Compute the SHA3-256 <a data-cite="CID#Multihash">Multihash</a> of the
UTF-8 encoded |canonicalizedEvent|. Let |hash| be the result.
                </li>
                <li>
Encode |hash| using base58-btc encoding, prepending the
<a data-cite="CID#Multibase">Multibase</a> (`z`) character to the encoding. Let
|encodedHash| be the result.
                </li>
                <li>
Send a witnessing request to the |witness| by performing an HTTP POST on the
witness endpoint. The body of the POST is a JSON object containing a
`digestMultibase` property with |encodedHash| as the associated value. Let
|proof| be the result. If witnessing fails, an error MUST be raised and SHOULD
convey an error type of `WITNESSING_ERROR`.
                </li>
                <li>
Append |proof| to the |proofs| array.
                </li>
              </ol>
            </li>
            <li>
Set |event|.`proof` to the |proofs| array containing attestations from all
witnesses. Each proof in the array represents an independent cryptographic
commitment by a witness that the event is valid and has been witnessed at a
specific point in time.
            </li>
          </ol>

          <p class="note">
The witness operation does not modify the Cryptographic Event Log itself. The
returned proofs are attached to the event in the log structure. Witnesses
provide independent validation and temporal attestation, enabling auditability
and resistance to single points of failure in the DID method infrastructure.
          </p>

        </section>

      </section>

      <section class="normative">
        <h3>Read</h3>

        <p>
        </p>

        <pre class="example nohighlight" title="Cryptographic event log after witnessing">
{
  "log": [
    {
      "@context": [
        "https://w3id.org/security/data-integrity/v2"
      ],
      "event": {
        "operation": {
          "type": "create",
          "data": {
            "@context": "https://www.w3.org/ns/did/v1.1",
            "id": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
            "assertionMethod": [
              {
                "id": "#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
              }
            ],
            "proof": {
              "type": "DataIntegrityProof",
              "cryptosuite": "ecdsa-jcs-2019",
              "created": "2025-12-03T12:41:21Z",
              "proofPurpose": "assertionMethod",
              "proofValue": "z3Z2BFFtVSZPjFGipCazyD8CLp8U5ovw4Mvvk4SkvNL3dgXrAH3PMeTDvxJzS9wd9dUrxLCAr3c53t2CmnNbcgscd",
              "verificationMethod": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
            }
          }
        }
      },
      "proof": [
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-03T12:44:32Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z5zybUDUyKkxgmHNYN8a3N4A33rKVv5pmnXHmHvbkXnkXrvfVFTSYNZxUr6C4QqEUoVdHJbtHykzVKr8rDLcE1zU9",
          "verificationMethod": "did:web:red-witness.example#vm-red-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-03T12:44:32Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z2c9Y4nBvGpQfyTzDcgmEjnVxaMTJNdPxfEmA8i4JwfVTe9jwRFQvSRSodEMqiVGwADMzW7dmqrAjecfm67nda7bW",
          "verificationMethod": "did:web:green-witness.example#vm-green-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-03T12:44:32Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z9QXFEcjThByMsLj5XbEmRwpzKh2318QvAhrM9V4Ddxni2mSgV1TW2e9J2Eqg4pQr9eWq3eBEa5gdGVon7Ba8d25",
          "verificationMethod": "did:web:blue-witness.example#vm-blue-1"
        }
      ]
    }
  ]
}
        </pre>

        <section class="normative">
          <h4>Document Read Algorithm</h4>

          <p>
          </p>

          <ol class="algorithm">
            <li>
            </li>
          </ol>

        </section>

      </section>

      <section class="normative">
        <h3>Update</h3>

        <p>
The update operation enables modifications to an existing `did:cel` [=DID
document=] while maintaining a verifiable audit trail through the Cryptographic
Event Log. When changes are made to a [=DID document=]—such as adding or removing
verification methods, updating service endpoints, or setting expiration
dates—the update operation ensures these modifications are cryptographically
signed and recorded in the event log. The operation proceeds in two phases:
first, the modified [=DID document=] receives a fresh [=data integrity proof=]
signed by an authorized assertion method key; second, a new update event is
appended to the Cryptographic Event Log with a hash link to the previous event,
creating an immutable chain of document history.
        </p>

        <p>
The hash-linking mechanism is central to the update operation's security
properties. Each update event includes a `previousEvent` property containing the
SHA3-256 hash of the prior event. This cryptographic chain ensures that any
tampering with historical events would be immediately detectable, as it would
break the hash links throughout the chain. The combination of cryptographic
proofs on the [=DID document=] and hash-linked events in the log provides both
authenticity guarantees (the document was signed by an authorized key) and
integrity guarantees (the complete history of changes is verifiable and
tamper-evident). After performing an update, implementations typically invoke
the witness operation to obtain independent temporal attestations of the
modification.
        </p>

        <p>
An example of an update operation serialized to a Cryptographic Event Log
is shown below:
        </p>

        <pre class="example nohighlight" title="Cryptographic event log after did:cel update">
{
  "log": [
    {
      "@context": [
        "https://w3id.org/security/data-integrity/v2"
      ],
      "event": {
        "operation": {
          "type": "create",
          "data": {
            "@context": "https://www.w3.org/ns/did/v1.1",
            "id": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
            "assertionMethod": [
              {
                "id": "#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
              }
            ],
            "proof": {
              "type": "DataIntegrityProof",
              "cryptosuite": "ecdsa-jcs-2019",
              "created": "2025-12-03T12:41:21Z",
              "proofPurpose": "assertionMethod",
              "proofValue": "z3Z2BFFtVSZPjFGipCazyD8CLp8U5ovw4Mvvk4SkvNL3dgXrAH3PMeTDvxJzS9wd9dUrxLCAr3c53t2CmnNbcgscd",
              "verificationMethod": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
            }
          }
        }
      },
      "proof": [
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-03T12:44:32Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z5zybUDUyKkxgmHNYN8a3N4A33rKVv5pmnXHmHvbkXnkXrvfVFTSYNZxUr6C4QqEUoVdHJbtHykzVKr8rDLcE1zU9",
          "verificationMethod": "did:web:red-witness.example#vm-red-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-03T12:44:32Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z2c9Y4nBvGpQfyTzDcgmEjnVxaMTJNdPxfEmA8i4JwfVTe9jwRFQvSRSodEMqiVGwADMzW7dmqrAjecfm67nda7bW",
          "verificationMethod": "did:web:green-witness.example#vm-green-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-03T12:44:32Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z9QXFEcjThByMsLj5XbEmRwpzKh2318QvAhrM9V4Ddxni2mSgV1TW2e9J2Eqg4pQr9eWq3eBEa5gdGVon7Ba8d25",
          "verificationMethod": "did:web:blue-witness.example#vm-blue-1"
        }
      ]
    },
    {
      "@context": [
        "https://w3id.org/security/data-integrity/v2"
      ],
      "event": {
        "previousEvent": "zW1h4Eejr9bT2uZUWVvStrA61QBUUVLgjW8zC63QUvGMbc7",
        "operation": {
          "type": "update",
          "data": {
            "@context": "https://www.w3.org/ns/did/v1.1",
            "id": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
            "assertionMethod": [
              {
                "id": "#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
              }
            ],
            "authentication": [
              {
                "id": "#zDnaevoeYvJDAdbTPzuiBkDyk83VL1cWK68aUGUopvLBuUVMj",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaevoeYvJDAdbTPzuiBkDyk83VL1cWK68aUGUopvLBuUVMj"
              }
            ],
            "proof": {
              "type": "DataIntegrityProof",
              "cryptosuite": "ecdsa-jcs-2019",
              "created": "2025-12-03T12:56:25Z",
              "proofPurpose": "assertionMethod",
              "proofValue": "z4AAsnpBKdMd5fws1Gjy2gQeyuTBXGM9fXrg3kS53nsF4f2hDGRmLUhWcgnMTuaC3FCAsVNRCbUah4X6Efm5kmA2T",
              "verificationMethod": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
            }
          }
        }
      },
      "proof": [
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-14T15:43:08Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z2XXjpGHZMK2c5X2aeqS7AQ1uZDwQpvoNyCPqp4DrTUowqvAKq9NwSRFsBYKg58Hj1DmtRkku4ELPS3UbJQGQYDnk",
          "verificationMethod": "did:web:red-witness.example#vm-red-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-14T15:43:08Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z4tDHCFcWcpMDenJWSVDEBg2eEDEZq46PL1cG4XKc157QwWfWBPTDwXdzFi6xQoRRhTdRYCvw3oHAxG1oaQ35JzKc",
          "verificationMethod": "did:web:green-witness.example#vm-green-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-14T15:43:08Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "zPdSjfJ5egfLjRU2Cppt1avQ726acTKgtPJnvJURarMcvEkRJXCDeRKh4bWGreyHKgfvNZxFVe97g4MmsWL7bdKG",
          "verificationMethod": "did:web:blue-witness.example#vm-blue-1"
        }
      ]
    }
  ]
}
        </pre>

        <section class="normative">
          <h4>Document Update Algorithm</h4>

          <p>
The following algorithm specifies how to update an existing `did:cel`
[=DID document=] and record the change in the Cryptographic Event Log. The update
operation consists of two phases: regenerating the cryptographic proof on the
modified [=DID document=], and appending a hash-linked update event to the log. The
algorithm takes a [=map=] |didDocument| (the modified [=DID document=]), a [=map=]
|assertionMethod| (the key pair to use for signing), and a [=map=] |cel| (the
existing Cryptographic Event Log) as input. Output is the updated |didDocument|
with a new proof and the updated |cel| with the new event appended, or an error.
Whenever this algorithm encodes strings, it MUST use UTF-8 encoding.
          </p>

          <ol class="algorithm">
            <li>
Update the proof on the [=DID Document=] by performing the following steps:
              <ol class="algorithm">
                <li>
Let |newDidDocument| be a copy of |didDocument|.
                </li>
                <li>
If |newDidDocument| contains a `proof` property, remove it. Any
existing proof will be replaced with a new proof reflecting the current state
of the document.
                </li>
                <li>
Create a [=data integrity proof=] with the cryptosuite and a signer derived from
|assertionMethod|. Let |proof| be the result of this step.
                </li>
                <li>
Set |newDidDocument|.`proof` to |proof|.
                </li>
                <li>
Set |didDocument| to |newDidDocument|.
                </li>
              </ol>
            </li>
            <li>
Append the update event to the Cryptographic Event Log by performing the
following steps:
              <ol class="algorithm">
                <li>
If |cel|.`log` does not contain any events, an error MUST be raised and
SHOULD convey an error type of `MALFORMED_CEL_ERROR`.
                </li>
                <li>
Perform the following steps to create a hash link to the previous event:
                  <ol class="algorithm">
                    <li>
Let |lastEvent| be the most recent event in |cel|.`log`, which will be the
last entry in the array.
                    </li>
                    <li>
Canonicalize |lastEvent| using JSON Canonicalization Scheme (JCS) as specified
in [[RFC8785]]. Let |canonicalizedEvent| be the result.
                    </li>
                    <li>
Compute the SHA3-256 <a data-cite="CID#Multihash">Multihash</a> of the
UTF-8 encoded |canonicalizedEvent|. Let |hash| be the result.
                    </li>
                    <li>
Encode |hash| using base58-btc encoding, prepending the
<a data-cite="CID#Multibase">Multibase</a> (`z`) character to the encoding. Let
|encodedHash| be the result.
                    </li>
                  </ol>
                </li>
                <li>
Create a new event object ([=map=] |updateEvent|) with the following structure:
                  <ol class="algorithm">
                    <li>
Set |updateEvent|.`event` to a new [=map=].
                    </li>
                    <li>
Set |updateEvent|.`event`.`previousEvent` to |encodedHash|.
This creates the hash-linked chain connecting this event to the previous event.
                    </li>
                    <li>
Set |updateEvent|.`event`.`operation` to a new [=map=].
                    </li>
                    <li>
Set |updateEvent|.`event`.`operation`.`type` to the string `update`.
                    </li>
                    <li>
Set |updateEvent|.`event`.`operation`.`data`
to the updated |didDocument| (which now includes the new proof).
                    </li>
                  </ol>
                </li>
                <li>
Append |updateEvent| to |cel|.`log`.
                </li>
              </ol>
            </li>
            <li>
Return the updated |didDocument| and updated |cel|. The |didDocument| now has
a fresh cryptographic proof, and the |cel| contains a new hash-linked event
recording the update operation.
            </li>
          </ol>

          <p class="note">
The update operation maintains the integrity of the Cryptographic Event Log
through hash-linking. Each update event includes a `previousEvent` property
containing the hash of the prior event, creating a verifiable chain that
prevents tampering and enables auditing of the [=DID document=]'s complete history.
After updating, implementations invoke the witness operation to obtain
independent attestations of the update event.
          </p>

          <p class="issue" title="Sign operations, not DID documents?">
The current algorithm has the controller sign the [=DID document=] to provide
an assurance that the controller intended to make the modification to the
[=DID document=]. The chain of events is witnessed, including all the hash-links
back in history, to ensure that the order of events isn't reshuffled. In
addition, it's presumed that registering storage requires the controller to
perform the storage operation (another signature, but doesn't end up in the
cryptographic log). This might result in a vulnerability. For example,
an attacker might take a previously signed [=DID document=] and modifying
the update operation to be a deactivation operation. In theory, registering
this change would be prevented by the attacker not being able to sign the
registration call (unless there was a vulnerability with the registration
mechanism). This seems brittle, and in order to avoid the brittleness, we
might just want the [=DID controller=] to sign the entire operation instead of
only signing the [=DID document=].
          </p>

        </section>

      </section>

      <section class="normative">
        <h3>Deactivate</h3>

        <p>
        </p>

        <pre class="example nohighlight" title="Cryptographic event log after did:cel deactivation">
{
  "log": [
    {
      "@context": [
        "https://w3id.org/security/data-integrity/v2"
      ],
      "event": {
        "operation": {
          "type": "create",
          "data": {
            "@context": "https://www.w3.org/ns/did/v1.1",
            "id": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
            "assertionMethod": [
              {
                "id": "#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
              }
            ],
            "proof": {
              "type": "DataIntegrityProof",
              "cryptosuite": "ecdsa-jcs-2019",
              "created": "2025-12-03T12:41:21Z",
              "proofPurpose": "assertionMethod",
              "proofValue": "z3Z2BFFtVSZPjFGipCazyD8CLp8U5ovw4Mvvk4SkvNL3dgXrAH3PMeTDvxJzS9wd9dUrxLCAr3c53t2CmnNbcgscd",
              "verificationMethod": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
            }
          }
        }
      },
      "proof": [
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-03T12:44:32Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z5zybUDUyKkxgmHNYN8a3N4A33rKVv5pmnXHmHvbkXnkXrvfVFTSYNZxUr6C4QqEUoVdHJbtHykzVKr8rDLcE1zU9",
          "verificationMethod": "did:web:red-witness.example#vm-red-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-03T12:44:32Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z2c9Y4nBvGpQfyTzDcgmEjnVxaMTJNdPxfEmA8i4JwfVTe9jwRFQvSRSodEMqiVGwADMzW7dmqrAjecfm67nda7bW",
          "verificationMethod": "did:web:green-witness.example#vm-green-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-03T12:44:32Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z9QXFEcjThByMsLj5XbEmRwpzKh2318QvAhrM9V4Ddxni2mSgV1TW2e9J2Eqg4pQr9eWq3eBEa5gdGVon7Ba8d25",
          "verificationMethod": "did:web:blue-witness.example#vm-blue-1"
        }
      ]
    },
    {
      "@context": [
        "https://w3id.org/security/data-integrity/v2"
      ],
      "event": {
        "previousEvent": "zW1h4Eejr9bT2uZUWVvStrA61QBUUVLgjW8zC63QUvGMbc7",
        "operation": {
          "type": "update",
          "data": {
            "@context": "https://www.w3.org/ns/did/v1.1",
            "id": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
            "assertionMethod": [
              {
                "id": "#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
              }
            ],
            "authentication": [
              {
                "id": "#zDnaevoeYvJDAdbTPzuiBkDyk83VL1cWK68aUGUopvLBuUVMj",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaevoeYvJDAdbTPzuiBkDyk83VL1cWK68aUGUopvLBuUVMj"
              }
            ],
            "proof": {
              "type": "DataIntegrityProof",
              "cryptosuite": "ecdsa-jcs-2019",
              "created": "2025-12-03T12:56:25Z",
              "proofPurpose": "assertionMethod",
              "proofValue": "z4AAsnpBKdMd5fws1Gjy2gQeyuTBXGM9fXrg3kS53nsF4f2hDGRmLUhWcgnMTuaC3FCAsVNRCbUah4X6Efm5kmA2T",
              "verificationMethod": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
            }
          }
        }
      },
      "proof": [
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-14T15:43:08Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z2XXjpGHZMK2c5X2aeqS7AQ1uZDwQpvoNyCPqp4DrTUowqvAKq9NwSRFsBYKg58Hj1DmtRkku4ELPS3UbJQGQYDnk",
          "verificationMethod": "did:web:red-witness.example#vm-red-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-14T15:43:08Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z4tDHCFcWcpMDenJWSVDEBg2eEDEZq46PL1cG4XKc157QwWfWBPTDwXdzFi6xQoRRhTdRYCvw3oHAxG1oaQ35JzKc",
          "verificationMethod": "did:web:green-witness.example#vm-green-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-14T15:43:08Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "zPdSjfJ5egfLjRU2Cppt1avQ726acTKgtPJnvJURarMcvEkRJXCDeRKh4bWGreyHKgfvNZxFVe97g4MmsWL7bdKG",
          "verificationMethod": "did:web:blue-witness.example#vm-blue-1"
        }
      ]
    },
    {
      "event": {
        "previousEvent": "zW1gXfEvNdtiphfwXSJYT3aYEkGrVtm3HNiknPEq8mS6vDK",
        "operation": {
          "type": "deactivate",
          "data": {
            "@context": "https://www.w3.org/ns/did/v1.1",
            "id": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
            "assertionMethod": [
              {
                "id": "#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
              }
            ],
            "authentication": [
              {
                "id": "#zDnaevoeYvJDAdbTPzuiBkDyk83VL1cWK68aUGUopvLBuUVMj",
                "type": "Multikey",
                "controller": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE",
                "publicKeyMultibase": "zDnaevoeYvJDAdbTPzuiBkDyk83VL1cWK68aUGUopvLBuUVMj"
              }
            ],
            "proof": {
              "type": "DataIntegrityProof",
              "cryptosuite": "ecdsa-jcs-2019",
              "created": "2025-12-03T13:01:13Z",
              "proofPurpose": "assertionMethod",
              "proofValue": "z4H2BvSz53LPmoQphooggR3STDvftuTji7QTTyegGfKxNBfuvTjpNJBBMhkt7VPz2RX2U9i6jtKBXuHXfgjwu3ABB",
              "verificationMethod": "did:cel:zW1jPC3ViLfgPJX6KaPMhymin3LpATUgYTS7N58FLHtQ4HE#zDnaei5odivPwAt8q8QFF1cKCtz6gMkVpb9PBacKBzUNcT9UV"
            }
          }
        }
      },
      "proof": [
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-14T15:43:08Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z2XXjpGHZMK2c5X2aeqS7AQ1uZDwQpvoNyCPqp4DrTUowqvAKq9NwSRFsBYKg58Hj1DmtRkku4ELPS3UbJQGQYDnk",
          "verificationMethod": "did:web:red-witness.example#vm-red-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-14T15:43:08Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "z4tDHCFcWcpMDenJWSVDEBg2eEDEZq46PL1cG4XKc157QwWfWBPTDwXdzFi6xQoRRhTdRYCvw3oHAxG1oaQ35JzKc",
          "verificationMethod": "did:web:green-witness.example#vm-green-1"
        },
        {
          "type": "DataIntegrityProof",
          "cryptosuite": "ecdsa-jcs-2019",
          "created": "2025-12-14T15:43:08Z",
          "proofPurpose": "assertionMethod",
          "proofValue": "zPdSjfJ5egfLjRU2Cppt1avQ726acTKgtPJnvJURarMcvEkRJXCDeRKh4bWGreyHKgfvNZxFVe97g4MmsWL7bdKG",
          "verificationMethod": "did:web:blue-witness.example#vm-blue-1"
        }
      ]
    }
  ]
}
        </pre>

        <section class="normative">
          <h4>Document Deactivation Algorithm</h4>

          <p>
          </p>

          <ol class="algorithm">
            <li>
            </li>
          </ol>

        </section>

      </section>

    </section>

    <section class="informative">
      <h2>Privacy Considerations</h2>

      <p>
This section contains a variety of privacy considerations that people using
the `did:cel` Method are advised to consider before deploying this
technology in a production setting. Readers are urged to read the
<a data-cite="?CID#privacy-considerations">Privacy Considerations</a> section
of the [[[CID]]] specification, as well as the
<a data-cite="?DID#privacy-considerations">Privacy Considerations</a> section
of the [[[DID]]] specification, before reading this section.
      </p>

      <section>
        <h3>Public Event Log Visibility</h3>

        <p>
The Cryptographic Event Log (CEL) for a DID is designed to be publicly
verifiable, which means that the complete history of [=DID document=] operations,
including creation, updates, additions, and removals of verification methods
and services, is permanently recorded and accessible. This transparency
enables auditability and trust but comes at the cost of revealing temporal
patterns and the evolution of a DID's capabilities over time. Observers can
analyze the log to determine when verification methods were added or expired,
when services were introduced or removed, and how frequently the [=DID document=]
has been modified.
        </p>

        <p>
To mitigate this privacy concern, implementers might carefully consider what
information is included in [=DID documents=] and when updates are performed.
Batch multiple related changes into a single update operation when possible
to reduce the granularity of information exposed through temporal analysis.
For use cases requiring higher privacy, consider using ephemeral [=DIDs=] that
are rotated regularly, or employing [=DIDs=] with shorter retention periods for
their event logs. Organizations might also document their DID rotation and
update policies to help users understand the privacy implications of using
particular [=DIDs=].
        </p>
      </section>

      <section>
        <h3>Correlation via Witness Selection</h3>

        <p>
The CEL architecture relies on witness services to provide attestations for
DID operations. The specific set of witnesses chosen to attest to an event
can serve as a correlatable fingerprint, especially if the witness
configuration is unique or rarely used. If a DID consistently uses the same
set of witnesses across multiple operations, or if the witness selection
pattern is distinctive, observers might be able to correlate different [=DIDs=]
or activities as belonging to the same entity or organization. This
correlation risk increases when custom witness services are deployed or when
non-standard witness configurations are used.
        </p>

        <p>
To reduce correlation risk, implementers might use commonly deployed and
widely adopted witness services when privacy is a concern. Using the same
witness configuration as other entities in the ecosystem provides herd
privacy by making it difficult to distinguish one [=DID controller=] from
another based solely on witness selection. For higher privacy requirements,
consider implementing witness rotation strategies where different witness
sets are used for different operations, though this might be balanced against
the operational complexity and verification requirements. Standardizing
witness selection policies across an ecosystem can also help establish common
configurations that enhance privacy through ubiquity.
        </p>
      </section>

      <section>
        <h3>Temporal Metadata Leakage</h3>

        <p>
Each event in the CEL includes temporal information, either explicitly
through timestamps in witness proofs or implicitly through the sequence and
timing of operations. This temporal metadata can reveal patterns about the
DID controller's activities, operational hours, time zones, or response times
to security incidents. For example, if verification methods are consistently
updated during specific hours, this might reveal information about the
organization's business hours or geographic location. Rapid succession of
updates might indicate automated processes or security incidents, while long
periods of inactivity followed by bursts of activity can reveal operational
patterns.
        </p>

        <p>
Implementers can mitigate temporal metadata leakage by implementing delays or
jitter in update operations to obscure the precise timing of changes.
Automated systems might avoid predictable update schedules and instead use
randomized timing within acceptable windows. For sensitive operations,
consider batching updates and releasing them at randomized intervals to
prevent timing correlation. Organizations might also be aware that even
without explicit timestamps, the sequence of events and witness attestation
timing can leak temporal information, so careful consideration of when to
perform DID operations is important for privacy-sensitive use cases.
        </p>
      </section>

      <section>
        <h3>Hash-Linked History Immutability</h3>

        <p>
The hash-linking mechanism that chains events together in the CEL provides
strong integrity guarantees but also creates an immutable, permanent record
of all DID operations. Once an event is added to the log and witnessed, it
cannot be removed or modified without breaking the cryptographic chain. This
means that information about previous verification methods, services, or
other metadata remains permanently visible in the log even after being
removed from the current [=DID document=]. This immutability can be problematic
for privacy if sensitive information was inadvertently included in earlier
versions of the [=DID document=], or if the history of changes itself reveals
sensitive information about the [=DID controller=]'s activities or relationships.
        </p>

        <p>
To address the immutability concern, implementers might exercise caution
when including information in [=DID documents=], as any data added will become
part of the permanent record. Before performing operations, carefully review
the information being added to ensure it does not contain sensitive data that
needs to remain private. For cases where the historical record becomes
problematic, [=DID controllers=] can deactivate the current DID and create a new
one, though this breaks continuity and requires updating all systems that
reference the old DID. Alternatively, implement clear documentation and
guidelines for [=DID controllers=] about what information might and might not
be included in [=DID documents=] to prevent privacy issues before they occur.
        </p>
      </section>

      <section>
        <h3>DID Identifier Persistence</h3>

        <p>
A DID identifier in the `did:cel` method is derived from or includes
cryptographic material from the initial creation event, making it persistent
and correlatable across all uses. Unlike some privacy-preserving identifier
systems that allow for easy rotation or unlinkable presentations, a
`did:cel` identifier remains constant and serves as a permanent correlation
point. Any entity that observes the DID identifier in multiple contexts can
definitively link those interactions as involving the same [=DID controller=].
This persistence is valuable for establishing long-term identity and trust
but directly conflicts with privacy goals that require unlinkability between
different interactions or contexts.
        </p>

        <p>
For scenarios requiring unlinkability, implementers might not reuse the same
DID across different contexts or relationships. Instead, create separate [=DIDs=]
for different purposes, relationships, or contexts where correlation might
be prevented. Implement DID management practices that include regular
rotation of [=DIDs=] when appropriate, and clearly document which [=DIDs=] are used
for which purposes. Organizations might also provide tooling to help users
manage multiple [=DIDs=] and understand the privacy implications of DID reuse.
For use cases where both persistence and privacy are required, consider
layering additional privacy-preserving mechanisms on top of the DID
infrastructure, such as using [=verifiable credentials=] with unlinkable
presentation features.
        </p>
      </section>

      <section>
        <h3>Verification Method Enumeration</h3>

        <p>
DID documents contain verification methods that specify the cryptographic
keys and their purposes (authentication, assertion, key agreement, etc.). The
complete set of verification methods, their types, cryptographic algorithms,
and relationship assignments can serve as a unique fingerprint for a DID,
especially when non-standard cryptographic suites are used or when the
combination of verification methods is unusual. Even when using common
cryptographic suites, the specific number and configuration of verification
methods for different purposes can reveal information about the DID
controller's intended use cases, security posture, or organizational
structure.
        </p>

        <p>
To reduce the identifiability of [=DIDs=] through verification method
enumeration, implementers might favor standard, commonly used verification
method configurations that are widely deployed in the ecosystem. Avoid
creating unique or unusual combinations of verification methods unless
specifically required. When possible, use the minimum number of verification
methods necessary for the intended functionality to reduce the uniqueness of
the configuration. For organizations deploying multiple [=DIDs=], consider
standardizing on common verification method templates that are used across
many [=DIDs=] to prevent fingerprinting. Documentation might also guide users on
recommended verification method configurations that balance functionality
with privacy considerations.
        </p>
      </section>

      <section>
        <h3>Service Endpoint Disclosure</h3>

        <p>
DID documents can include service endpoints that specify how to interact with
services related to the [=DID controller=]. These service endpoints often contain
URLs or other network identifiers that reveal information about the DID
controller's infrastructure, service providers, or operational environment.
Service endpoints might point to specific servers, domains, or third-party
services, which can be used to correlate [=DIDs=], identify the organizations or
individuals behind them, or map out relationships between different entities.
Even when service endpoints use common infrastructure, the specific
combination or configuration of services can serve as a identifying
characteristic.
        </p>

        <p>
Implementers might carefully consider whether service endpoints need to be
included in the [=DID document=] itself, or whether they could be communicated
through other channels that provide better privacy properties. When service
endpoints might be included, use generic or shared infrastructure that does
not reveal specific information about the [=DID controller=]. Consider using
privacy-preserving relay services, proxy servers, or shared service
infrastructure that is used by multiple entities to prevent correlation.
Avoid including service endpoints that point to unique or rarely used
domains. For higher privacy scenarios, service endpoint information might be
exchanged out-of-band or through encrypted communication channels rather than
being published in the public [=DID document=].
        </p>
      </section>

      <section>
        <h3>Witness Service Metadata</h3>

        <p>
When witness services attest to CEL events, they create proofs that include
metadata such as their witness identifier, the cryptographic suite used, and
potentially timing information. While this metadata is necessary for
verification, it can also reveal information about the [=DID controller=]'s
relationships with witness services, their witness selection strategy, and
potentially their geographic location or operational preferences. If a DID
consistently uses witnesses that are associated with specific geographic
regions, industries, or organizations, this association can reveal
information about the [=DID controller=]. Additionally, the specific combination
of witness services chosen might reveal business relationships or trust
relationships that the [=DID controller=] has established.
        </p>

        <p>
To mitigate privacy concerns related to witness metadata, implementers might
select witness services that are widely used and geographically distributed
to avoid revealing location information. When possible, use witness services
that are operated by neutral, well-known entities rather than
industry-specific or organization-specific witnesses that might reveal
affiliations. Consider implementing witness rotation policies that vary the
set of witnesses used across different operations to prevent long-term
correlation. Documentation might guide users on selecting witness services
that align with their privacy requirements, and ecosystems might encourage
the deployment of diverse, broadly available witness services that can be
used interchangeably to enhance herd privacy.
        </p>
      </section>

      <section>
        <h3>Long-term Cryptographic Commitment</h3>

        <p>
The cryptographic algorithms and key types chosen during DID creation and
throughout the DID's lifecycle represent long-term commitments that are
permanently recorded in the CEL. These cryptographic choices can reveal
information about when the DID was created (based on algorithm popularity at
that time), the security requirements or preferences of the [=DID controller=],
and potentially the systems or software used to create the DID. As
cryptographic algorithms age and new algorithms are adopted, the continued
use of older algorithms or the early adoption of newer ones can serve as
identifying characteristics. Furthermore, the cryptographic choices reveal
the [=DID controller=]'s security posture and risk tolerance.
        </p>

        <p>
Implementers might provide clear guidance on recommended cryptographic
algorithms that balance security requirements with privacy considerations.
Using widely adopted, current best-practice cryptographic algorithms helps
provide herd privacy by ensuring that many [=DIDs=] share similar cryptographic
profiles. Organizations might plan for cryptographic agility by supporting
algorithm migration paths that allow updating to newer algorithms without
requiring DID replacement. When upgrading cryptographic algorithms,
coordinate with broader ecosystem adoption to avoid standing out as an early
or late adopter. Documentation might explain the privacy implications of
different cryptographic choices and provide recommendations for standard
configurations that are appropriate for different use cases.
        </p>
      </section>

      <section>
        <h3>Resolution Privacy</h3>

        <p>
Resolving a DID to obtain its current [=DID document=] and verify the CEL
requires accessing the log data, which might be stored in various locations
such as distributed ledgers, decentralized storage systems, or centralized
repositories. The act of resolving a DID can reveal information about the
resolver's interest in that particular DID to the entities operating the
storage or retrieval infrastructure. This creates potential for surveillance,
tracking of resolution patterns, or profiling of which [=DIDs=] are being
resolved by which entities. Network-level metadata such as IP addresses,
timing of resolution requests, and patterns of correlated resolutions can
further compromise privacy by revealing resolver identity or activities.
        </p>

        <p>
To enhance resolution privacy, implementers might use privacy-preserving
resolution mechanisms such as proxies, VPNs, or onion routing when resolving
DIDs. Aggressive caching of [=DID documents=] and CEL data reduces the frequency
of resolution requests and limits the metadata exposed to storage providers.
Consider using decentralized resolution infrastructure that does not rely on
single points that can monitor resolution patterns. Implement resolution
protocols that minimize metadata leakage, such as fetching data through
encrypted channels or using obfuscation techniques that prevent correlation
of multiple resolution requests. For high-privacy scenarios, design systems
that pre-fetch or batch resolve multiple [=DIDs=] to obscure which specific [=DIDs=]
are of interest, and utilize privacy-preserving query protocols where
available.
        </p>
      </section>

    </section>

    <section class="informative">
      <h2>Security Considerations</h2>

      <p>
This section contains a variety of security considerations that people using
the `did:cel` Method are advised to consider before deploying this
technology in a production setting. Readers are urged to read the
<a data-cite="?CID#security-considerations">Security Considerations</a> section
of the [[[CID]]] specification, as well as the
<a data-cite="?DID#security-considerations">Security Considerations</a> section
of the [[[DID]]] specification, before reading this section.
      </p>

    </section>

  </section>

  <section class="appendix informative">
    <h2>Acknowledgements</h2>

    <p>
The Working Group would like to thank the following individuals for reviewing
and providing feedback on the specification (in alphabetical order):
    </p>

    <p>
TBD...
    </p>
  </section>
  </body>
</html>
